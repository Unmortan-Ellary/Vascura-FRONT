<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vascura FRONT v0.144</title>
    <style>
        /* CSS Variables - Dark theme (default) */
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #252525;
            --bg-tertiary: #303030;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent: #6a5acd;
            --accent-hover: #7b68ee;
            --border: #404040;
            --user-bg: #2a2a3e;
            --llm-bg: #1e1e2e;
            --error: #ff5252;
            --success: #4caf50;
            --stop-red: #8b0000;
            --stop-red-hover: #a52a2a;
            --chat-width: 100%;
            --text-size: 14px;
            --action-btn-bg: rgba(255, 255, 255, 0.1);
            --action-btn-hover: rgba(255, 255, 255, 0.2);
            --action-btn-size: 22px;
            --action-btn-icon-size: 12px;
            --chat-locked-bg: #1a1a1a;
            --chat-locked-text: #555555;
            --chat-locked-border: #333333;
            --disabled-btn-bg: rgba(255, 255, 255, 0.05);
            --disabled-btn-text: #555555;
            --disabled-btn-cursor: not-allowed;
            --md-bold: #ee7272;
            --md-italic: #bababa;
            --md-strikethrough: #95a5a6;
            --md-inline-code: #f39c12;
            --md-code-bg: #2c3e50;
            --md-code-text: #ecf0f1;
            --md-h1: #e74c3c;
            --md-h2: #e67e22;
            --md-h3: #f1c40f;
            --md-h4: #2ecc71;
            --md-h5: #3498db;
            --md-h6: #9b59b6;
            --md-blockquote: #7f8c8d;
            --md-link: #3498db;
            --md-image: #eccb8e;
            --md-ul: #2ecc71;
            --md-ol: #3498db;
            --md-task-checked: #2ecc71;
            --md-task-unchecked: #95a5a6;
            --ai-avatar-bg: #8B0000;
            --ai-avatar-hover: #A52A2A;
            --chats-panel-width: 300px;
            --settings-panel-width: 300px;
            --chat-item-bg: #303030;
            --active-chat-in-collapsed-group: #4a4a6a;
            --completion-bg: #2a2a3e;
            --completion-text: #a0a0a0;
            --completion-icon: #6a5acd;
            --search-status-bg: rgba(106, 90, 205, 0.1);
            --search-status-text: #a0a0a0;
            --search-status-border: #6a5acd;
            --debug-window-bg: #1a1a1a;
            --debug-window-border: #6a5acd;
            --debug-header-bg: #252525;
            --debug-section-bg: #252525;
            --debug-section-border: #404040;
            --debug-code-bg: #1e1e2e;
            --debug-code-text: #e0e0e0;
        }

        /* White theme colors */
        :root.white-theme {
        --border: #cccccc;
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e0e0e0;
            --text-primary: #333333;
            --text-secondary: #666666;
            --user-bg: #e6e6fa;
            --llm-bg: #f0f0f0;
            --error: #d32f2f;
            --success: #388e3c;
            --stop-red: #d32f2f;
            --stop-red-hover: #f44336;
            --action-btn-bg: rgba(0, 0, 0, 0.1);
            --action-btn-hover: rgba(0, 0, 0, 0.2);
            --chat-locked-bg: #f5f5f5;
            --chat-locked-text: #aaaaaa;
            --chat-locked-border: #dddddd;
            --disabled-btn-bg: rgba(0, 0, 0, 0.05);
            --disabled-btn-text: #aaaaaa;
            --md-bold: #c62828;
            --md-italic: #6e6e6e;
            --md-strikethrough: #757575;
            --md-inline-code: #e65100;
            --md-code-bg: #eceff1;
            --md-code-text: #263238;
            --md-h1: #c62828;
            --md-h2: #d84315;
            --md-h3: #f57f17;
            --md-h4: #2e7d32;
            --md-h5: #1565c0;
            --md-h6: #6a1b9a;
            --md-blockquote: #546e7a;
            --md-link: #1565c0;
            --md-image: #8f6b28;
            --md-ul: #2e7d32;
            --md-ol: #1565c0;
            --md-task-checked: #2e7d32;
            --md-task-unchecked: #757575;
            --ai-avatar-bg: #d32f2f;
            --ai-avatar-hover: #f44336;
            --chat-item-bg: #f0f0f0;
            --active-chat-in-collapsed-group: #d0d0e0;
            --completion-bg: #f0f0f0;
            --completion-text: #666666;
            --debug-window-bg: #f5f5f5;
            --debug-header-bg: #ffffff;
            --debug-section-bg: #ffffff;
            --debug-section-border: #cccccc;
            --debug-code-bg: #f0f0f0;
            --debug-code-text: #333333;
        }

        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Courier New', Courier, monospace;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Panel Styles */
        .chats-panel, .settings-panel {
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            position: relative;
            min-width: 0;
        }

        .settings-panel {
            border-left: 1px solid var(--border);
            border-right: none;
        }

        .chats-panel {
            width: var(--chats-panel-width);
        }

        .settings-panel {
            width: var(--settings-panel-width);
        }

        /* Resize handles */
        .chats-panel-resize-handle, .settings-panel-resize-handle {
            position: fixed;
            top: 0;
            width: 8px;
            height: 100vh;
            background-color: transparent;
            cursor: col-resize;
            z-index: 10;
            transition: background-color 0.2s;
        }

        .chats-panel-resize-handle {
            left: calc(var(--chats-panel-width) - 0px);
        }

        .settings-panel-resize-handle {
            right: calc(var(--settings-panel-width) - 8px);
        }

        .chats-panel-resize-handle:hover, .settings-panel-resize-handle:hover {
            background-color: var(--accent);
            opacity: 0.5;
        }

        .chats-panel.collapsed, .settings-panel.collapsed {
            width: 0;
            overflow: hidden;
        }

        .chats-panel.collapsed .chats-header, .settings-panel.collapsed .settings-header,
        .chats-panel.collapsed .chats-list, .settings-panel.collapsed .settings-content {
            display: none;
        }

        .chats-panel.collapsed .chats-panel-resize-handle, .settings-panel.collapsed .settings-panel-resize-handle {
            width: 16px;
            background-color: var(--accent);
            opacity: 0.3;
        }

        .chats-panel.collapsed .chats-panel-resize-handle:hover, .settings-panel.collapsed .settings-panel-resize-handle:hover {
            opacity: 0.7;
        }

        /* Header Styles */
        .chats-header, .settings-header, .dialogue-header {
            height: 56px;
            padding: 0 15px;
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .settings-header {
            position: sticky;
            top: 0;
            z-index: 5;
        }

        .chats-header h2, .settings-title, .dialogue-title {
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }

        .chats-header-actions, .settings-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .icon-btn {
            width: 36px;
            height: 36px;
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: background-color 0.2s;
        }

        .icon-btn:hover {
            background-color: var(--accent-hover);
        }

        .icon-btn:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }

        /* Chats List */
        .chats-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        /* Group styles */
        .chat-group {
            margin-bottom: -8px;
            border-radius: 6px;
            overflow: hidden;
        }

        .chat-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            user-select: none;
            background-color: var(--bg-secondary);
            border-radius: 6px;
            margin-bottom: 0;
            position: relative;
        }

        .chat-group.locked .chat-group-header {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .chat-group.locked .chat-group-header:hover {
            background-color: var(--bg-secondary);
        }

        .chat-group.locked .chat-group-actions {
            display: none !important;
        }

        .chat-group-title {
            display: flex;
            align-items: center;
            font-weight: 500;
        }

        .chat-group-title::before {
            content: '‚ñº';
            font-size: 12px;
            margin-right: 8px;
            transition: transform 0.2s;
        }

        .chat-group.collapsed .chat-group-title::before {
            transform: rotate(-90deg);
        }

        .chat-group-actions {
            position: absolute;
            right: 8px;
            bottom: 8px;
            display: none;
            gap: 4px;
        }

        .chat-group-header:hover .chat-group-actions {
            display: flex;
        }

        .chat-group-content {
            padding: 0 10px 10px;
        }

        .chat-group.collapsed .chat-group-content {
            display: none;
        }

        /* Ungrouped section */
        .ungrouped-section {
            margin-top: 16px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }

        .ungrouped-header {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            padding: 0 4px;
        }

        /* Chat item */
        .chat-item {
            padding: 12px;
            margin-bottom: 8px;
            background-color: var(--chat-item-bg);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
        }

        .chat-item:hover {
            background-color: var(--accent);
        }

        .chat-item.active {
            background-color: var(--accent);
        }

        .chat-item.active-in-collapsed-group {
            background-color: var(--active-chat-in-collapsed-group);
            border-left: 3px solid var(--accent);
        }

        .chat-item.locked {
            background-color: var(--chat-locked-bg);
            color: var(--chat-locked-text);
            cursor: not-allowed;
            border: 1px solid var(--chat-locked-border);
            opacity: 0.7;
        }

        .chat-item.locked:hover {
            background-color: var(--chat-locked-bg);
        }

        .chat-item.locked .chat-item-actions {
            display: none !important;
        }

        .chat-item-title {
            font-weight: 500;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-item.locked .chat-item-title {
            color: var(--chat-locked-text);
        }

        .chat-item-date {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .chat-item.locked .chat-item-date {
            color: var(--chat-locked-text);
        }

        .chat-item-actions {
            position: absolute;
            right: 8px;
            bottom: 8px;
            display: none;
            gap: 4px;
        }

        .chat-item:hover .chat-item-actions {
            display: flex;
        }

        .chat-action-btn {
            background-color: var(--action-btn-bg);
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            width: var(--action-btn-size);
            height: var(--action-btn-size);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--action-btn-icon-size);
            transition: background-color 0.2s, transform 0.1s;
        }

        .chat-action-btn:hover {
            background-color: var(--action-btn-hover);
            transform: scale(1.1);
        }

        /* Dialogue Panel */
        .dialogue-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
            position: relative;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: nowrap;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--text-secondary);
        }

        .status-dot.connected {
            background-color: var(--success);
        }

        .status-dot.error {
            background-color: var(--error);
        }

        .brand-link {
           color: var(--accent);
            text-decoration: none;
            margin-right: 10px;
            font-size: 14px;
            transition: color 0.2s;
        }

        .brand-link:hover {
            color: var(--accent-hover);
           text-decoration: underline;
        }

        /* Messages */
        .dialogue-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
        }

        .chat-container {
            max-width: var(--chat-width);
            margin: 0 auto;
            width: 100%;
        }

        .message {
            display: flex;
            gap: 12px;
            max-width: 100%;
        }

        /* Ignored message styling */
        .message.ignored {
            opacity: 0.6;
        }

        .message.ignored .message-content {
            background-color: var(--bg-tertiary);
            border: 1px dashed var(--border);
        }

        .message.ignored .message-text {
            color: var(--text-secondary);
            /* Limit to 2 lines */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            /* Make it non-interactive */
            cursor: default;
            user-select: text;
        }

        /* Hide message actions for ignored messages by default */
        .message.ignored .message-actions {
            display: none;
        }

        /* Show message actions for ignored messages on hover */
        .message.ignored:hover .message-actions {
            display: flex;
        }

        /* For ignored messages, only show ignore, copy, and delete buttons */
        .message.ignored .message-actions .message-action-btn:not(.ignore-message):not(.copy-message):not(.delete-message) {
            display: none;
        }

        /* Ensure ignore, copy, and delete buttons are visible for ignored messages on hover */
        .message.ignored:hover .message-actions .ignore-message,
        .message.ignored:hover .message-actions .copy-message,
        .message.ignored:hover .message-actions .delete-message {
            display: flex;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background-color: var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            overflow: hidden;
            flex-shrink: 0;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }

        .message-avatar.ai-avatar {
            background-color: var(--ai-avatar-bg);
        }

        .message-avatar.ai-avatar:hover {
            background-color: var(--ai-avatar-hover);
        }

        .message-avatar:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(139, 0, 0, 0.4);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 0 6px rgba(139, 0, 0, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(139, 0, 0, 0);
            }
        }

        .message-avatar.generating {
            animation: pulse 2s infinite;
            background-color: var(--ai-avatar-hover);
        }

        .message-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .message-content {
            flex: 1;
            background-color: var(--bg-secondary);
            border-radius: 8px;
            padding: 12px 15px;
            position: relative;
        }

        .message.user .message-content {
            background-color: var(--user-bg);
        }

        .message.llm .message-content {
            background-color: var(--llm-bg);
        }

        .message-text {
            font-family: 'Consolas', 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 20px;
            outline: none;
            font-size: var(--text-size);
            line-height: 1.5;
        }

        /* Markdown syntax highlighting */
        .md-bold { color: var(--md-bold); }
        .md-italic { color: var(--md-italic); }
        .md-bold-italic {
            background: linear-gradient(to right, var(--md-bold), var(--md-italic));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        .md-strikethrough {
            color: var(--md-strikethrough);
            text-decoration: line-through;
        }
        .md-inline-code {
            color: var(--md-inline-code);
            background-color: rgba(243, 156, 18, 0.1);
            padding: 0 2px;
            border-radius: 3px;
        }
        .md-code-block {
            background-color: var(--md-code-bg);
            color: var(--md-code-text);
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 5px 0;
        }
        .md-h1, .md-h2, .md-h3, .md-h4, .md-h5, .md-h6 {
            color: var(--md-h1);
            font-weight: bold;
        }
        .md-h2 { color: var(--md-h2); }
        .md-h3 { color: var(--md-h3); }
        .md-h4 { color: var(--md-h4); }
        .md-h5 { color: var(--md-h5); }
        .md-h6 { color: var(--md-h6); }
        .md-blockquote {
            color: var(--md-blockquote);
            border-left: 3px solid var(--md-blockquote);
            padding-left: 10px;
            margin: 5px 0;
        }
        .md-hr {
            color: var(--border);
            border-top: 1px solid var(--border);
            margin: 10px 0;
        }
        .md-link {
            color: var(--md-link);
            text-decoration: underline;
        }
        .md-image {
            color: var(--md-image);
        }
        .md-ul {
            color: var(--md-ul);
        }
        .md-ol {
            color: var(--md-ol);
        }
        .md-task-checked {
            color: var(--md-task-checked);
        }
        .md-task-unchecked {
            color: var(--md-task-unchecked);
        }

        .message-actions {
            position: absolute;
            right: 8px;
            bottom: 8px;
            display: none;
            gap: 4px;
        }

        .message-content:hover .message-actions {
            display: flex;
        }

        .message-action-btn {
            background-color: var(--action-btn-bg);
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            width: var(--action-btn-size);
            height: var(--action-btn-size);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--action-btn-icon-size);
            transition: background-color 0.2s, transform 0.1s;
        }

        .message-action-btn:hover {
            background-color: var(--action-btn-hover);
            transform: scale(1.1);
        }

        .message-action-btn:disabled {
            background-color: var(--disabled-btn-bg);
            color: var(--disabled-btn-text);
            cursor: var(--disabled-btn-cursor);
            transform: none;
        }

        .message-action-btn:disabled:hover {
            background-color: var(--disabled-btn-bg);
            transform: none;
        }

        /* Input area */
        .dialogue-input {
            padding: 15px 20px;
            background-color: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .completion-suggestion, .search-status {
            border-radius: 4px;
            padding: 8px 15px;
            margin-bottom: 8px;
            font-size: var(--text-size);
            display: none;
            max-width: var(--chat-width);
            margin-left: auto;
            margin-right: auto;
        }

        .completion-suggestion {
            background-color: var(--completion-bg);
            color: var(--completion-text);
            pointer-events: none;
            user-select: none;
            border-left: 3px solid var(--completion-icon);
        }

        .completion-suggestion.visible {
            display: block;
        }

        .completion-suggestion .tab-icon {
            color: var(--completion-icon);
            margin-right: 8px;
        }

        .search-status {
            background-color: var(--search-status-bg);
            color: var(--search-status-text);
            border-left: 3px solid var(--search-status-border);
        }

        .search-status.visible {
            display: block;
        }

        .search-status .search-icon {
            color: var(--search-status-border);
            margin-right: 8px;
        }

        .dialogue-input-container {
            max-width: var(--chat-width);
            margin: 0 auto;
            width: 100%;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .dialogue-input-field {
            flex: 1;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px 15px;
            color: var(--text-primary);
            font-size: var(--text-size);
            resize: none;
            outline: none;
            min-height: 38px;
            max-height: 285px;
            line-height: 19px;
            overflow-y: auto;
            font-family: 'Consolas', 'Courier New', Courier, monospace;
        }

        .dialogue-input-field:focus {
            border-color: var(--accent);
        }

        .send-btn {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: background-color 0.2s;
            flex-shrink: 0;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .send-btn:hover {
            background-color: var(--accent-hover);
        }

        .send-btn:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }

        .send-btn.stop-btn {
            background-color: var(--stop-red);
        }

        .send-btn.stop-btn:hover {
            background-color: var(--stop-red-hover);
        }

        /* Settings Panel */
        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .settings-section {
            padding: 15px;
            border-bottom: 1px solid var(--border);
        }

        .settings-section-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 500;
            cursor: pointer;
        }

        .settings-section-title::after {
            content: '‚ñº';
            font-size: 12px;
            transition: transform 0.2s;
        }

        .settings-section.collapsed .settings-section-title::after {
            transform: rotate(-90deg);
        }

        .settings-section-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .settings-section.collapsed .settings-section-content {
            display: none;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .setting-label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .setting-input, .setting-textarea {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
        }

        .setting-input:focus, .setting-textarea:focus {
            border-color: var(--accent);
        }

        .setting-textarea {
            resize: vertical;
            min-height: 200px;
            /* You can optionally set a max-height if desired */
            /* max-height: 400px; */
        }

        .setting-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .setting-slider, .debug-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: var(--bg-tertiary);
            outline: none;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .setting-slider:hover, .debug-slider:hover {
            background: rgba(106, 90, 205, 0.2);
        }

        /* WebKit (Chrome, Safari, Edge) slider thumb */
        .setting-slider::-webkit-slider-thumb, .debug-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .setting-slider::-webkit-slider-thumb:hover, .debug-slider::-webkit-slider-thumb:hover {
            background: var(--accent-hover);
        }

        .debug-slider::-webkit-slider-thumb {
            width: 12px;
            height: 12px;
        }

        /* Firefox slider thumb */
        .setting-slider::-moz-range-thumb, .debug-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            border: none;
            transition: background 0.2s;
        }

        .setting-slider::-moz-range-thumb:hover, .debug-slider::-moz-range-thumb:hover {
            background: var(--accent-hover);
        }

        .debug-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
        }

        .setting-slider-value, .debug-slider-value {
            width: 65px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 5px 8px;
            color: var(--text-primary);
            font-size: 14px;
            text-align: center;
            outline: none;
        }

        .debug-slider-value {
            width: 60px;
            font-size: 12px;
            padding: 2px 5px;
        }

        .setting-slider-value:focus, .debug-slider-value:focus {
            border-color: var(--accent);
        }

        /* Toggle Switch */
        .setting-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--accent);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        /* File Input for Avatar */
        .avatar-input {
            display: none;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-container {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            width: 400px;
            max-width: 90%;
        }

        .group-selection-container {
            width: 300px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 15px;
            text-align: center;
        }

        .modal-buttons {
            display: flex;
            justify-content: space-between;
        }

        .modal-btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .modal-cancel {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .modal-cancel:hover {
            background-color: var(--border);
        }

        .modal-save {
            background-color: var(--accent);
            color: white;
        }

        .modal-save:hover {
            background-color: var(--accent-hover);
        }

        .modal-save:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }

        /* Avatar Crop Modal */
        .avatar-crop-preview {
            width: 200px;
            height: 200px;
            margin: 0 auto 15px;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            background-color: var(--bg-tertiary);
            cursor: grab;
        }

        .avatar-crop-preview.dragging {
            cursor: grabbing;
        }

        .avatar-crop-image {
            position: absolute;
            transform-origin: center;
            transition: transform 0.1s ease;
            user-select: none;
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
        }

        .avatar-crop-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .avatar-crop-zoom {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .avatar-crop-zoom-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: var(--bg-tertiary);
            outline: none;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .avatar-crop-zoom-slider:hover {
            background: rgba(106, 90, 205, 0.2);
        }

        /* WebKit (Chrome, Safari, Edge) slider thumb for avatar crop */
        .avatar-crop-zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .avatar-crop-zoom-slider::-webkit-slider-thumb:hover {
            background: var(--accent-hover);
        }

        /* Firefox slider thumb for avatar crop */
        .avatar-crop-zoom-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            border: none;
            transition: background 0.2s;
        }

        .avatar-crop-zoom-slider::-moz-range-thumb:hover {
            background: var(--accent-hover);
        }

        .avatar-crop-zoom-value {
            width: 50px;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 5px;
            color: var(--text-primary);
            text-align: center;
        }

        /* Group Selection Modal */
        .group-selection-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .group-selection-item {
            padding: 8px 12px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .group-selection-item:hover {
            background-color: var(--accent);
        }

        /* Debug Window */
        .debug-window {
            position: fixed;
            top: 56px;
            right: 20px;
            width: 600px;
            height: calc(100vh - 76px);
            background-color: var(--debug-window-bg);
            border: 1px solid var(--debug-window-border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .debug-window.visible {
            display: flex;
        }
        
        .debug-header {
            background-color: var(--debug-header-bg);
            padding: 10px 15px;
            border-bottom: 1px solid var(--debug-window-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .debug-title {
            font-weight: 500;
            color: var(--accent);
        }
        
        .debug-close {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .debug-close:hover {
            background-color: var(--action-btn-hover);
        }
        
        .debug-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        
        .debug-sliders {
            background-color: var(--debug-section-bg);
            border-bottom: 1px solid var(--debug-section-border);
            padding: 15px;
        }
        
        .debug-sliders-title {
            font-weight: 500;
            color: var(--accent);
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .debug-sliders-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .debug-slider-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .debug-slider-label {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }
        
        .debug-section {
            margin-bottom: 0;
            background-color: var(--debug-section-bg);
            border: 1px solid var(--debug-section-border);
            border-radius: 0;
            overflow: hidden;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .debug-section-header {
            background-color: var(--bg-tertiary);
            padding: 8px 12px;
            font-weight: 500;
            color: var(--accent);
            border-bottom: 1px solid var(--debug-section-border);
            flex-shrink: 0;
        }
        
        .debug-section-content {
            padding: 10px;
            font-size: 12px;
            font-family: 'Consolas', 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            flex: 1;
        }
        
        .debug-code {
            background-color: var(--debug-code-bg);
            color: var(--debug-code-text);
            padding: 10px;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', Courier, monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            flex: 1;
        }
        
        .debug-timestamp {
            color: var(--text-secondary);
            font-size: 10px;
            margin-top: 5px;
        }

        /* Model Selection Dropdown */
        .model-selection-container {
            position: relative;
        }

        .model-dropdown {
            position: absolute;
            bottom: 100%;  /* Position above the input */
            left: 0;
            right: 0;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            margin-bottom: 5px;  /* Space between input and dropdown */
        }

        .model-dropdown.visible {
            display: block;
        }

        .model-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .model-option:hover {
            background-color: var(--accent);
        }

        .model-option.selected {
            background-color: var(--accent);
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel - Chats List -->
        <div class="chats-panel" id="chats-panel">
            <div class="chats-header">
                <h2>Chats</h2>
                <div class="chats-header-actions">
                    <button class="icon-btn" id="new-chat-btn" title="New Chat">+</button>
                    <button class="icon-btn" id="new-group-btn" title="New Group">üìÅ</button>
                </div>
            </div>
            <div class="chats-list" id="chats-list">
                <!-- Groups and chat items will be dynamically added here -->
            </div>
            <div class="chats-panel-resize-handle" id="chats-panel-resize-handle"></div>
        </div>

        <!-- Middle Panel - Dialogue -->
        <div class="dialogue-panel">
            <div class="dialogue-header">
                <div class="dialogue-title" id="dialogue-title">Select a chat or create a new one</div>
                <div class="status-indicator">
                    <a href="https://x.com/unmortan" target="_blank" class="brand-link">// Vascura FRONT v0.144 //</a>
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text">Disconnected</span>
                </div>
            </div>
            <div class="dialogue-messages" id="dialogue-messages">
                <div class="chat-container" id="chat-container">
                    <!-- Messages will be dynamically added here -->
                </div>
            </div>
            <div class="dialogue-input">
                <div class="completion-suggestion" id="completion-suggestion">
                    <span class="tab-icon">‚á•</span>
                    <span id="completion-text"></span>
                </div>
                <div class="search-status" id="search-status">
                    <span class="search-icon">üîç</span>
                    <span id="search-status-text">Searching the web...</span>
                </div>
                <div class="dialogue-input-container">
                    <textarea class="dialogue-input-field" id="dialogue-input" placeholder="Type your message here..." rows="2"></textarea>
                    <button class="send-btn" id="send-btn" disabled>Send</button>
                </div>
            </div>
        </div>

        <!-- Right Panel - Settings -->
        <div class="settings-panel" id="settings-panel">
            <div class="settings-panel-resize-handle" id="settings-panel-resize-handle"></div>
            <div class="settings-header">
                <div class="settings-title">Settings</div>
                <div class="settings-actions">
                    <button class="icon-btn" id="copy-settings-btn" title="Copy Settings (N/A System Prompt)">üìã</button>
                    <button class="icon-btn" id="paste-settings-btn" title="Paste Settings (N/A System Prompt)">üìù</button>
                    <span style="color: var(--text-secondary); margin: 0 5px;">|</span>
                    <button class="icon-btn" id="export-btn" title="Export">üì§</button>
                    <button class="icon-btn" id="import-btn" title="Import">üì•</button>
                </div>
            </div>
            <div class="settings-content">
                <!-- System Prompt Section -->
                <div class="settings-section" id="system-prompt-section">
                    <div class="settings-section-title">System Prompt</div>
                    <div class="settings-section-content">
                        <div class="setting-item">
                            <textarea class="setting-textarea" id="system-prompt" placeholder="Enter system prompt..."></textarea>
                        </div>
                    </div>
                </div>
                
                <!-- Parameters Section -->
                <div class="settings-section" id="parameters-section">
                    <div class="settings-section-title">Sampling</div>
                    <div class="settings-section-content">
                        <div class="setting-item">
                            <label class="setting-label">Temperature</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="temp-slider" min="0" max="2" step="0.01" value="0.7">
                                <input type="number" class="setting-slider-value" id="temp-value" min="0" max="2" step="0.01" value="0.7">
                            </div>
                        </div>
                        <div class="setting-item strict-api-hidden">
                            <label class="setting-label">Top K</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="topk-slider" min="0" max="200" step="1" value="40">
                                <input type="number" class="setting-slider-value" id="topk-value" min="0" max="200" step="1" value="40">
                            </div>
                        </div>
                        <div class="setting-item strict-api-hidden">
                            <label class="setting-label">Repeat Penalty</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="repeat-penalty-slider" min="1" max="2" step="0.01" value="1.1">
                                <input type="number" class="setting-slider-value" id="repeat-penalty-value" min="1" max="2" step="0.01" value="1.1">
                            </div>
                        </div>
                        <div class="setting-item strict-api-hidden">
                            <label class="setting-label">Min P</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="minp-slider" min="0" max="1" step="0.01" value="0.05">
                                <input type="number" class="setting-slider-value" id="minp-value" min="0" max="1" step="0.01" value="0.05">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Top P</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="topp-slider" min="0" max="1" step="0.01" value="0.95">
                                <input type="number" class="setting-slider-value" id="topp-value" min="0" max="1" step="0.01" value="0.95">
                            </div>
                        </div>
                        <div class="setting-item strict-api-hidden">
                            <label class="setting-label">DRY</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="dry-slider" min="0" max="5" step="0.01" value="0.5">
                                <input type="number" class="setting-slider-value" id="dry-value" min="0" max="5" step="0.01" value="0.5">
                            </div>
                        </div>
                        <div class="setting-item strict-api-hidden">
                            <label class="setting-label">XTC</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="xtc-slider" min="0" max="1" step="0.01" value="0.1">
                                <input type="number" class="setting-slider-value" id="xtc-value" min="0" max="1" step="0.01" value="0.1">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Max Tokens</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="max-tokens-slider" min="-1" max="16384" step="1" value="-1">
                                <input type="number" class="setting-slider-value" id="max-tokens-value" min="-1" max="16384" step="1" value="-1">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-toggle">
                                <label class="setting-label">Thinking Model</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="thinking-model-toggle">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Interface Section -->
                <div class="settings-section" id="interface-section">
                    <div class="settings-section-title">Interface</div>
                    <div class="settings-section-content">
                        <div class="setting-item">
                            <label class="setting-label">Chat Width</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="chat-width-slider" min="50" max="100" step="5" value="100">
                                <input type="number" class="setting-slider-value" id="chat-width-value" min="50" max="100" step="5" value="100">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Text Size</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="text-size-slider" min="8" max="36" step="1" value="14">
                                <input type="number" class="setting-slider-value" id="text-size-value" min="8" max="36" step="1" value="14">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Tokens to Suggest</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="tokens-to-suggest-slider" min="0" max="100" step="1" value="20">
                                <input type="number" class="setting-slider-value" id="tokens-to-suggest-value" min="0" max="100" step="1" value="20">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Web Search Agents</label>
                            <div class="setting-slider-container">
                                <input type="range" class="setting-slider" id="web-search-agents-slider" min="1" max="9" step="1" value="2">
                                <input type="number" class="setting-slider-value" id="web-search-agents-value" min="1" max="9" step="1" value="2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-toggle">
                                <label class="setting-label">Web Search</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="web-search-toggle">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-toggle">
                                <label class="setting-label">Markdown Color Coding</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="markdown-color-coding-toggle" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-toggle">
                                <label class="setting-label">White Theme</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="white-theme-toggle">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- API Settings Section -->
                <div class="settings-section" id="api-settings-section">
                    <div class="settings-section-title">API Settings</div>
                    <div class="settings-section-content">
                        <div class="setting-item">
                            <div class="setting-toggle">
                                <label class="setting-label">LM Studio Endpoint</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="lm-studio-endpoint-toggle" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-toggle">
                                <label class="setting-label">Strict API</label>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="strict-api-toggle">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">API Endpoint</label>
                            <input type="text" class="setting-input" id="api-endpoint" placeholder="http://localhost:1234/v1" value="http://localhost:1234/v1">
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">API Key (Optional)</label>
                            <input type="password" class="setting-input" id="api-key" placeholder="Enter API key if required">
                        </div>
                        <div class="setting-item model-selection-container">
                            <label class="setting-label">Model Name (Optional)</label>
                            <input type="text" class="setting-input" id="model-name" placeholder="Leave empty for default model">
                            <div class="model-dropdown" id="model-dropdown">
                                <!-- Model options will be dynamically added here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for avatar upload -->
    <input type="file" class="avatar-input" id="avatar-input" accept="image/*">

    <!-- Avatar Crop Modal (hidden by default) -->
    <div class="modal avatar-crop-modal" id="avatar-crop-modal" style="display: none;">
        <div class="modal-container">
            <div class="modal-title">Crop Avatar</div>
            <div class="avatar-crop-preview" id="avatar-crop-preview">
                <img class="avatar-crop-image" id="avatar-crop-image" src="" alt="Avatar preview">
            </div>
            <div class="avatar-crop-controls">
                <div class="avatar-crop-zoom">
                    <label>Zoom:</label>
                    <input type="range" class="avatar-crop-zoom-slider" id="avatar-crop-zoom-slider" min="-10" max="10" step="0.1" value="0">
                    <input type="number" class="avatar-crop-zoom-value" id="avatar-crop-zoom-value" min="-10" max="10" step="0.1" value="0">
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-cancel" id="avatar-crop-cancel">Cancel</button>
                    <button class="modal-btn modal-save" id="avatar-crop-save">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Group Selection Modal (hidden by default) -->
    <div class="modal group-selection-modal" id="group-selection-modal" style="display: none;">
        <div class="modal-container group-selection-container">
            <div class="modal-title">Move to Group</div>
            <div class="group-selection-list" id="group-selection-list">
                <!-- Group options will be dynamically added here -->
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-cancel" id="group-selection-cancel">Cancel</button>
                <button class="modal-btn modal-save" id="group-selection-move" disabled>Move</button>
            </div>
        </div>
    </div>
    
    <!-- Debug Window (hidden by default) -->
    <div class="debug-window" id="debug-window">
        <div class="debug-header">
            <div class="debug-title">Web Search Debug</div>
            <button class="debug-close" id="debug-close">‚úï</button>
        </div>
        <div class="debug-content">
            <div class="debug-sliders">
                <div class="debug-sliders-title">Sampler Parameters</div>
                <div class="debug-sliders-grid">
                    <div class="debug-slider-item">
                        <div class="debug-slider-label">
                            <span>dry_base</span>
                            <input type="number" class="debug-slider-value" id="debug-dry-base-value" min="0" max="4" step="0.05" value="1.75">
                        </div>
                        <input type="range" class="debug-slider" id="debug-dry-base-slider" min="0" max="4" step="0.05" value="1.75">
                    </div>
                    <div class="debug-slider-item">
                        <div class="debug-slider-label">
                            <span>dry_allowed_length</span>
                            <input type="number" class="debug-slider-value" id="debug-dry-allowed-length-value" min="0" max="20" step="1" value="2">
                        </div>
                        <input type="range" class="debug-slider" id="debug-dry-allowed-length-slider" min="0" max="20" step="1" value="2">
                    </div>
                    <div class="debug-slider-item">
                        <div class="debug-slider-label">
                            <span>dry_penalty_last_n</span>
                            <input type="number" class="debug-slider-value" id="debug-dry-penalty-last-n-value" min="-1" max="8192" step="1" value="1024">
                        </div>
                        <input type="range" class="debug-slider" id="debug-dry-penalty-last-n-slider" min="-1" max="8192" step="1" value="1024">
                    </div>
                    <div class="debug-slider-item">
                        <div class="debug-slider-label">
                            <span>xtc_threshold</span>
                            <input type="number" class="debug-slider-value" id="debug-xtc-threshold-value" min="0" max="1" step="0.01" value="0.15">
                        </div>
                        <input type="range" class="debug-slider" id="debug-xtc-threshold-slider" min="0" max="1" step="0.01" value="0.15">
                    </div>
                </div>
            </div>
            <div class="debug-section">
                <div class="debug-section-header">Search Query</div>
                <div class="debug-section-content" id="debug-search-query"></div>
            </div>
            <div class="debug-section">
                <div class="debug-section-header">Raw Search Results</div>
                <div class="debug-code" id="debug-raw-results"></div>
            </div>
            <div class="debug-section">
                <div class="debug-section-header">LLM Summarization</div>
                <div class="debug-section-content" id="debug-llm-summary"></div>
            </div>
            <div class="debug-section">
                <div class="debug-section-header">System Message with Search Context</div>
                <div class="debug-code" id="debug-system-message"></div>
            </div>
        </div>
    </div>

    <script>
        // Application State
        const app = {
            chats: [],
            groups: [],
            currentChatId: null,
            settings: {
                systemPrompt: '',
                temperature: 0.8,
                topK: 40,
                repeatPenalty: 1.05,
                minP: 0.05,
                topP: 0.95,
                maxTokens: -1,
                apiEndpoint: 'http://localhost:1234/v1',
                apiKey: '',
                modelName: '',
                chatWidth: 80,
                textSize: 16,
                tokensToSuggest: 25,
                markdownColorCoding: true,
                whiteTheme: false,
                webSearchEnabled: false,
                webSearchAgents: 2,
                dryMultiplier: 0.0,
                xtcProbability: 0.0,
                thinkingModelEnabled: false,
                lmStudioEndpointEnabled: true,
                strictApiEnabled: false
            },
            uiSettings: {
                systemPromptHeight: 100,
                systemPromptCollapsed: false,
                parametersCollapsed: false,
                interfaceCollapsed: false,
                apiSettingsCollapsed: false
            },
            globalSettings: {
                chatsPanelWidth: 300,
                chatsPanelCollapsed: false
            },
            apiStatus: 'disconnected',
            isGenerating: false,
            currentAbortController: null,
            userScrolled: false,
            lastScrollTop: 0,
            scrollPositionBeforeGeneration: 0,
            wasAtBottomBeforeGeneration: false,
            avatarCrop: {
                currentRole: null,
                originalImage: null,
                zoom: 0,
                imageLoaded: false,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                imageStartX: 0,
                imageStartY: 0
            },
            panelResizing: {
                isResizing: false,
                panel: null,
                startX: 0,
                startWidth: 0
            },
            groupSelection: {
                chatId: null,
                selectedGroupId: null
            },
            textCompletion: {
                currentSuggestion: '',
                currentContext: '',
                isGenerating: false,
                currentAbortController: null,
                inputTimer: null,
                editingMessageId: null,
                editingElement: null,
                cursorPosition: 0,
                lastCursorPosition: 0,
                cursorPositionAtGeneration: 0,
                elementAtGeneration: null
            },
            webSearch: {
                isSearching: false,
                searchResults: [],
                debug: {
                    searchQuery: '',
                    rawResults: [],
                    llmSummary: '',
                    systemMessage: '',
                    apiLog: []  // New property to store API log entries
                },
                searchGoals: [
                    '',
                    'Information about Creators / Parents / Origin',
                    'Information about History / Life / Progression',
                    'Information about Impact / Influence / Outcome',
                    'Information about Use / Instruments / Application',
                    'Information about Visual / Look / View',
                    'Information about Numbers / Dates / Time',
                    'Information about End / Death / Finish',
                    'Information about Conclusion / Legacy / Aftershock'
                ]
            },
            thinkingModel: {
                buffer: '',
                isProcessing: false,
                messageId: null,
                hiddenContent: ''
            },
            debugSamplerParams: {
                dry_base: 1.75,
                dry_allowed_length: 2,
                dry_penalty_last_n: 1024,
                xtc_threshold: 0.15
            },
            modelSelection: {
                availableModels: [],
                isLoading: false,
                isDropdownVisible: false
            },
            copiedSettings: null // New property to store copied settings
        };

        // DOM Elements
        const elements = {
            // Chat elements
            chatsList: document.getElementById('chats-list'),
            chatsPanel: document.getElementById('chats-panel'),
            dialogueMessages: document.getElementById('dialogue-messages'),
            chatContainer: document.getElementById('chat-container'),
            dialogueTitle: document.getElementById('dialogue-title'),
            dialogueInput: document.getElementById('dialogue-input'),
            sendBtn: document.getElementById('send-btn'),
            newChatBtn: document.getElementById('new-chat-btn'),
            newGroupBtn: document.getElementById('new-group-btn'),
            avatarInput: document.getElementById('avatar-input'),
            statusDot: document.getElementById('status-dot'),
            statusText: document.getElementById('status-text'),
            
            // Settings elements
            settingsPanel: document.getElementById('settings-panel'),
            chatsPanelResizeHandle: document.getElementById('chats-panel-resize-handle'),
            settingsPanelResizeHandle: document.getElementById('settings-panel-resize-handle'),
            
            // Text completion elements
            completionSuggestion: document.getElementById('completion-suggestion'),
            completionText: document.getElementById('completion-text'),
            
            // Search elements
            searchStatus: document.getElementById('search-status'),
            searchStatusText: document.getElementById('search-status-text'),
            
            // Debug elements
            debugWindow: document.getElementById('debug-window'),
            debugClose: document.getElementById('debug-close'),
            debugSearchQuery: document.getElementById('debug-search-query'),
            debugRawResults: document.getElementById('debug-raw-results'),
            debugLlmSummary: document.getElementById('debug-llm-summary'),
            debugSystemMessage: document.getElementById('debug-system-message'),
            
            // Debug slider elements
            debugDryBaseSlider: document.getElementById('debug-dry-base-slider'),
            debugDryBaseValue: document.getElementById('debug-dry-base-value'),
            debugDryAllowedLengthSlider: document.getElementById('debug-dry-allowed-length-slider'),
            debugDryAllowedLengthValue: document.getElementById('debug-dry-allowed-length-value'),
            debugDryPenaltyLastNSlider: document.getElementById('debug-dry-penalty-last-n-slider'),
            debugDryPenaltyLastNValue: document.getElementById('debug-dry-penalty-last-n-value'),
            debugXtcThresholdSlider: document.getElementById('debug-xtc-threshold-slider'),
            debugXtcThresholdValue: document.getElementById('debug-xtc-threshold-value'),
            
            // Settings input elements
            systemPromptTextarea: document.getElementById('system-prompt'),
            tempSlider: document.getElementById('temp-slider'),
            tempValue: document.getElementById('temp-value'),
            topkSlider: document.getElementById('topk-slider'),
            topkValue: document.getElementById('topk-value'),
            repeatPenaltySlider: document.getElementById('repeat-penalty-slider'),
            repeatPenaltyValue: document.getElementById('repeat-penalty-value'),
            minpSlider: document.getElementById('minp-slider'),
            minpValue: document.getElementById('minp-value'),
            toppSlider: document.getElementById('topp-slider'),
            toppValue: document.getElementById('topp-value'),
            maxTokensSlider: document.getElementById('max-tokens-slider'),
            maxTokensValue: document.getElementById('max-tokens-value'),
            chatWidthSlider: document.getElementById('chat-width-slider'),
            chatWidthValue: document.getElementById('chat-width-value'),
            textSizeSlider: document.getElementById('text-size-slider'),
            textSizeValue: document.getElementById('text-size-value'),
            tokensToSuggestSlider: document.getElementById('tokens-to-suggest-slider'),
            tokensToSuggestValue: document.getElementById('tokens-to-suggest-value'),
            webSearchAgentsSlider: document.getElementById('web-search-agents-slider'),
            webSearchAgentsValue: document.getElementById('web-search-agents-value'),
            webSearchToggle: document.getElementById('web-search-toggle'),
            markdownColorCodingToggle: document.getElementById('markdown-color-coding-toggle'),
            whiteThemeToggle: document.getElementById('white-theme-toggle'),
            apiEndpointInput: document.getElementById('api-endpoint'),
            apiKeyInput: document.getElementById('api-key'),
            modelNameInput: document.getElementById('model-name'),
            exportBtn: document.getElementById('export-btn'),
            importBtn: document.getElementById('import-btn'),
            drySlider: document.getElementById('dry-slider'),
            dryValue: document.getElementById('dry-value'),
            xtcSlider: document.getElementById('xtc-slider'),
            xtcValue: document.getElementById('xtc-value'),
            thinkingModelToggle: document.getElementById('thinking-model-toggle'),
            lmStudioEndpointToggle: document.getElementById('lm-studio-endpoint-toggle'),
            strictApiToggle: document.getElementById('strict-api-toggle'),
            modelDropdown: document.getElementById('model-dropdown'),
            
            // New buttons
            copySettingsBtn: document.getElementById('copy-settings-btn'),
            pasteSettingsBtn: document.getElementById('paste-settings-btn'),
            
            // Settings section elements
            systemPromptSection: document.getElementById('system-prompt-section'),
            parametersSection: document.getElementById('parameters-section'),
            interfaceSection: document.getElementById('interface-section'),
            apiSettingsSection: document.getElementById('api-settings-section'),
            
            // Avatar crop elements
            avatarCropModal: document.getElementById('avatar-crop-modal'),
            avatarCropPreview: document.getElementById('avatar-crop-preview'),
            avatarCropImage: document.getElementById('avatar-crop-image'),
            avatarCropZoomSlider: document.getElementById('avatar-crop-zoom-slider'),
            avatarCropZoomValue: document.getElementById('avatar-crop-zoom-value'),
            avatarCropCancel: document.getElementById('avatar-crop-cancel'),
            avatarCropSave: document.getElementById('avatar-crop-save'),
            
            // Group selection elements
            groupSelectionModal: document.getElementById('group-selection-modal'),
            groupSelectionList: document.getElementById('group-selection-list'),
            groupSelectionCancel: document.getElementById('group-selection-cancel'),
            groupSelectionMove: document.getElementById('group-selection-move')
        };

        // Markdown syntax highlighting patterns
        const markdownPatterns = [
            { pattern: /"(.*?)"/g, className: 'md-image' },
            { pattern: /\*\*(.*?)\*\*/g, className: 'md-bold' },
            { pattern: /(?<!\*)\*(?!\*)(.*?)\*(?!\*)/g, className: 'md-italic' },
            { pattern: /(?<!_)_(?!_)(.*?)_(?!_)/g, className: 'md-italic' },
            { pattern: /\*\*\*(.*?)\*\*\*/g, className: 'md-bold-italic' },
            { pattern: /\*\*_(.*?)_\*\*/g, className: 'md-bold-italic' },
            { pattern: /_\*(.*?)\*_/g, className: 'md-bold-italic' },
            { pattern: /__(.*?)__/g, className: 'md-bold-italic' },
            { pattern: /~~(.*?)~~/g, className: 'md-strikethrough' },
            { pattern: /````([\s\S]*?)````/g, className: 'md-inline-code' },
            { pattern: /```([\s\S]*?)```/g, className: 'md-inline-code' },
            { pattern: /`(.*?)`/g, className: 'md-inline-code' },
            { pattern: /^###### (.*?)$/gm, className: 'md-h6' },
            { pattern: /^##### (.*?)$/gm, className: 'md-h5' },
            { pattern: /^#### (.*?)$/gm, className: 'md-h4' },
            { pattern: /^### (.*?)$/gm, className: 'md-h3' },
            { pattern: /^## (.*?)$/gm, className: 'md-h2' },
            { pattern: /^# (.*?)$/gm, className: 'md-h1' },
            { pattern: /^> (.*?)$/gm, className: 'md-blockquote' },
            { pattern: /!\[([^\]]+)\]\(([^)]+)\)/g, className: 'md-image' },
            { pattern: /\[([^\]]+)\]\(([^)]+)\)/g, className: 'md-link' },
            { pattern: /^[\-\*] (.*?)$/gm, className: 'md-ul' },
            { pattern: /^\+ (.*?)$/gm, className: 'md-ul' },
            { pattern: /^\d+\. (.*?)$/gm, className: 'md-ol' },
            { pattern: /^[\-\*] \[x\] (.*?)$/gmi, className: 'md-task-checked' },
            { pattern: /^[\-\*] \[ \] (.*?)$/gmi, className: 'md-task-unchecked' }
        ];

        // Utility Functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        function applyMarkdownHighlighting(text) {
            if (!app.settings.markdownColorCoding) {
                return text;
            }
            
            let highlightedText = text;
            
            markdownPatterns.forEach(({ pattern, className }) => {
                highlightedText = highlightedText.replace(pattern, (match, ...groups) => {
                    if (className === 'md-code-block') {
                        return `<div class="${className}">${groups[0]}</div>`;
                    }
                    
                    if (['md-h1', 'md-h2', 'md-h3', 'md-h4', 'md-h5', 'md-h6'].includes(className)) {
                        const headerLevel = className === 'md-h1' ? 1 : 
                                         className === 'md-h2' ? 2 : 
                                         className === 'md-h3' ? 3 : 
                                         className === 'md-h4' ? 4 : 
                                         className === 'md-h5' ? 5 : 6;
                        const headerPrefix = '#'.repeat(headerLevel) + ' ';
                        const content = match.substring(headerPrefix.length);
                        return `${headerPrefix}<span class="${className}">${content}</span>`;
                    }
                    
                    if (className === 'md-blockquote') {
                        const content = match.substring(2);
                        return `> <span class="${className}">${content}</span>`;
                    }
                    
                    if (className === 'md-hr') {
                        return `<div class="${className}">${match}</div>`;
                    }
                    
                    if (['md-ul', 'md-ol', 'md-task-checked', 'md-task-unchecked'].includes(className)) {
                        let prefix = '';
                        if (className === 'md-ul') {
                            prefix = match.match(/^[\-\*] /)[0];
                        } else if (className === 'md-ol') {
                            prefix = match.match(/^\d+\. /)[0];
                        } else if (className === 'md-task-checked') {
                            prefix = '- [x] ';
                        } else if (className === 'md-task-unchecked') {
                            prefix = '- [ ] ';
                        }
                        const content = match.substring(prefix.length);
                        return `${prefix}<span class="${className}">${content}</span>`;
                    }
                    
                    if (className === 'md-link' || className === 'md-image') {
                        return `<span class="${className}">${match}</span>`;
                    }
                    
                    if (['md-bold', 'md-italic', 'md-bold-italic', 'md-strikethrough', 'md-inline-code'].includes(className)) {
                        return `<span class="${className}">${match}</span>`;
                    }
                    
                    return match;
                });
            });
            
            return highlightedText;
        }

        // Storage Functions
        function loadFromStorage(key, defaultValue = null) {
            try {
                const stored = localStorage.getItem(key);
                return stored ? JSON.parse(stored) : defaultValue;
            } catch (e) {
                console.error(`Error loading ${key} from storage:`, e);
                return defaultValue;
            }
        }

        function saveToStorage(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
            } catch (e) {
                console.error(`Error saving ${key} to storage:`, e);
            }
        }

        function loadChatsFromStorage() {
            app.chats = loadFromStorage('llm-chats', []);
            
            // Ensure backward compatibility
            app.chats.forEach(chat => {
                if (chat.settingsPanelWidth === undefined) {
                    chat.settingsPanelWidth = 300;
                }
                if (chat.settingsPanelCollapsed === undefined) {
                    chat.settingsPanelCollapsed = false;
                }
                if (chat.settings && chat.settings.webSearchEnabled === undefined) {
                    chat.settings.webSearchEnabled = false;
                }
                if (chat.settings && chat.settings.webSearchAgents === undefined) {
                    chat.settings.webSearchAgents = 2;
                }
                if (chat.settings && chat.settings.dryMultiplier === undefined) {
                    chat.settings.dryMultiplier = 0.5;
                }
                if (chat.settings && chat.settings.xtcProbability === undefined) {
                    chat.settings.xtcProbability = 0.1;
                }
                if (chat.settings && chat.settings.thinkingModelEnabled === undefined) {
                    chat.settings.thinkingModelEnabled = false;
                }
                if (chat.settings && chat.settings.lmStudioEndpointEnabled === undefined) {
                    chat.settings.lmStudioEndpointEnabled = true;
                }
                if (chat.settings && chat.settings.strictApiEnabled === undefined) {
                    chat.settings.strictApiEnabled = false;
                }
                // Add ignored property to existing messages
                if (chat.messages) {
                    chat.messages.forEach(message => {
                        if (message.ignored === undefined) {
                            message.ignored = false;
                        }
                    });
                }
            });
            
            saveChatsToStorage();
        }

        function saveChatsToStorage() {
            saveToStorage('llm-chats', app.chats);
        }

        function loadGroupsFromStorage() {
            app.groups = loadFromStorage('llm-groups', []);
        }

        function saveGroupsToStorage() {
            saveToStorage('llm-groups', app.groups);
        }

        function loadGlobalSettings() {
            app.globalSettings = { ...app.globalSettings, ...loadFromStorage('llm-global-settings', {}) };
        }

        function saveGlobalSettings() {
            saveToStorage('llm-global-settings', app.globalSettings);
        }

        function loadLastSelectedChat() {
            const lastSelectedChatId = localStorage.getItem('llm-last-selected-chat');
            if (lastSelectedChatId) {
                const chatExists = app.chats.some(chat => chat.id === lastSelectedChatId);
                if (chatExists) {
                    app.currentChatId = lastSelectedChatId;
                }
            }
        }

        function saveLastSelectedChat() {
            if (app.currentChatId) {
                localStorage.setItem('llm-last-selected-chat', app.currentChatId);
            }
        }

        function loadDebugSamplerParams() {
            app.debugSamplerParams = { ...app.debugSamplerParams, ...loadFromStorage('llm-debug-sampler-params', {}) };
            
            // Update UI elements
            elements.debugDryBaseSlider.value = app.debugSamplerParams.dry_base;
            elements.debugDryBaseValue.value = app.debugSamplerParams.dry_base;
            elements.debugDryAllowedLengthSlider.value = app.debugSamplerParams.dry_allowed_length;
            elements.debugDryAllowedLengthValue.value = app.debugSamplerParams.dry_allowed_length;
            elements.debugDryPenaltyLastNSlider.value = app.debugSamplerParams.dry_penalty_last_n;
            elements.debugDryPenaltyLastNValue.value = app.debugSamplerParams.dry_penalty_last_n;
            elements.debugXtcThresholdSlider.value = app.debugSamplerParams.xtc_threshold;
            elements.debugXtcThresholdValue.value = app.debugSamplerParams.xtc_threshold;
        }

        function saveDebugSamplerParams() {
            saveToStorage('llm-debug-sampler-params', app.debugSamplerParams);
        }

        // UI Functions
        function updateSendButton() {
            if (app.isGenerating || app.webSearch.isSearching) {
                elements.sendBtn.textContent = 'Stop';
                elements.sendBtn.classList.add('stop-btn');
                elements.sendBtn.disabled = false;
                hideCompletionSuggestion();
            } else {
                elements.sendBtn.textContent = 'Send';
                elements.sendBtn.classList.remove('stop-btn');
                const hasText = elements.dialogueInput.value.trim().length > 0;
                elements.sendBtn.disabled = !app.currentChatId || !hasText;
            }
        }

        function updateAPIStatus(status) {
            app.apiStatus = status;
            
            elements.statusDot.className = 'status-dot';
            
            switch (status) {
                case 'connected':
                    elements.statusDot.classList.add('connected');
                    elements.statusText.textContent = 'Connected';
                    break;
                case 'connecting':
                    elements.statusText.textContent = 'Connecting...';
                    break;
                case 'busy':
                    elements.statusDot.classList.add('error');
                    elements.statusText.textContent = 'Server busy, waiting...';
                    break;
                case 'error':
                    elements.statusDot.classList.add('error');
                    elements.statusText.textContent = 'Error';
                    break;
                default:
                    elements.statusText.textContent = 'Disconnected';
            }
        }

        function showCompletionSuggestion(suggestion) {
            app.textCompletion.currentSuggestion = suggestion;
            elements.completionText.textContent = suggestion;
            elements.completionSuggestion.classList.add('visible');
        }

        function hideCompletionSuggestion() {
            app.textCompletion.currentSuggestion = '';
            elements.completionSuggestion.classList.remove('visible');
        }

        function showSearchStatus(statusText) {
            elements.searchStatusText.textContent = statusText;
            elements.searchStatus.classList.add('visible');
            app.webSearch.isSearching = true;
            updateSendButton();
            
            lockChatList(true);
            updateMessageActionButtons(true);
        }

        function hideSearchStatus() {
            elements.searchStatus.classList.remove('visible');
            app.webSearch.isSearching = false;
            updateSendButton();
            
            lockChatList(false);
            updateMessageActionButtons(false);
        }

        function lockChatList(lock) {
            const chatItems = document.querySelectorAll('.chat-item');
            const chatGroups = document.querySelectorAll('.chat-group');
            
            if (lock) {
                chatItems.forEach(item => item.classList.add('locked'));
                chatGroups.forEach(group => group.classList.add('locked'));
                elements.newChatBtn.disabled = true;
                elements.newGroupBtn.disabled = true;
            } else {
                chatItems.forEach(item => item.classList.remove('locked'));
                chatGroups.forEach(group => group.classList.remove('locked'));
                elements.newChatBtn.disabled = false;
                elements.newGroupBtn.disabled = false;
            }
        }

        function updateMessageActionButtons(disable) {
            const regenerateButtons = document.querySelectorAll('.regenerate-message');
            const continueButtons = document.querySelectorAll('.continue-message');
            const reactButtons = document.querySelectorAll('.react-message');
            const ignoreButtons = document.querySelectorAll('.ignore-message');
            
            [...regenerateButtons, ...continueButtons, ...reactButtons, ...ignoreButtons].forEach(button => {
                button.disabled = disable;
            });
            
            if (app.settings.thinkingModelEnabled || !app.settings.lmStudioEndpointEnabled) {
                continueButtons.forEach(button => {
                    button.disabled = true;
                });
            }
        }

        function updateContinueButtonsState() {
            const continueButtons = document.querySelectorAll('.continue-message');
            continueButtons.forEach(button => {
                button.disabled = app.settings.thinkingModelEnabled || !app.settings.lmStudioEndpointEnabled;
            });
        }

        /**
         * Check if the scrollbar is at the bottom of the chat dialogue with a threshold
         * @returns {boolean} - True if the scrollbar is at the bottom within the threshold
         */
        function isAtBottom() {
            const scrollTop = elements.dialogueMessages.scrollTop;
            const scrollHeight = elements.dialogueMessages.scrollHeight;
            const clientHeight = elements.dialogueMessages.clientHeight;
            
            // Consider "at bottom" if within 100px of the actual bottom
            const threshold = 100;
            return scrollHeight - scrollTop - clientHeight <= threshold;
        }

        /**
         * Scroll to the bottom of the chat dialogue if the user was at the bottom
         * or if force is set to true
         * @param {boolean} force - Force scrolling regardless of user position
         */
        function scrollToBottom(force = false) {
            if (force || isAtBottom()) {
                elements.dialogueMessages.scrollTop = elements.dialogueMessages.scrollHeight;
                app.userScrolled = false;
            }
        }

        function autoResizeTextarea() {
            const textarea = elements.dialogueInput;
            textarea.style.height = 'auto';
            const newHeight = Math.min(textarea.scrollHeight, 285);
            textarea.style.height = newHeight + 'px';
            updateSendButton();
        }

        function syncSendButtonHeight() {
            const textareaHeight = elements.dialogueInput.offsetHeight;
            elements.sendBtn.style.height = `${textareaHeight}px`;
        }

        function applyPanelSettings() {
            document.documentElement.style.setProperty('--chats-panel-width', `${app.globalSettings.chatsPanelWidth}px`);
            
            if (app.globalSettings.chatsPanelCollapsed) {
                elements.chatsPanel.classList.add('collapsed');
            } else {
                elements.chatsPanel.classList.remove('collapsed');
            }
            
            if (app.currentChatId) {
                const chat = app.chats.find(c => c.id === app.currentChatId);
                if (chat) {
                    const settingsPanelWidth = chat.settingsPanelWidth || 300;
                    const settingsPanelCollapsed = chat.settingsPanelCollapsed || false;
                    
                    document.documentElement.style.setProperty('--settings-panel-width', `${settingsPanelWidth}px`);
                    
                    if (settingsPanelCollapsed) {
                        elements.settingsPanel.classList.add('collapsed');
                    } else {
                        elements.settingsPanel.classList.remove('collapsed');
                    }
                }
            } else {
                document.documentElement.style.setProperty('--settings-panel-width', '300px');
                elements.settingsPanel.classList.remove('collapsed');
            }
            
            updateResizeHandlePositions();
        }

        function updateResizeHandlePositions() {
            const chatsPanelWidth = app.globalSettings.chatsPanelCollapsed ? 0 : app.globalSettings.chatsPanelWidth;
            elements.chatsPanelResizeHandle.style.left = `${chatsPanelWidth - 0}px`;
            
            let settingsPanelWidth = 300;
            if (app.currentChatId) {
                const chat = app.chats.find(c => c.id === app.currentChatId);
                if (chat && !chat.settingsPanelCollapsed) {
                    settingsPanelWidth = chat.settingsPanelWidth || 300;
                }
            }
            
            const containerWidth = document.querySelector('.container').offsetWidth;
            elements.settingsPanelResizeHandle.style.right = `${settingsPanelWidth - 8}px`;
        }

        /**
         * Updates visibility of all parameters based on both Strict API and LM Studio Endpoint settings
         * This ensures proper interaction between the two switches
         */
        function updateParameterVisibility() {
            // Update strict-api-hidden elements (Top K, Repeat Penalty, Min P, DRY, XTC)
            const strictApiHiddenElements = document.querySelectorAll('.strict-api-hidden');
            
            if (app.settings.strictApiEnabled) {
                strictApiHiddenElements.forEach(element => {
                    element.style.display = 'none';
                });
            } else {
                strictApiHiddenElements.forEach(element => {
                    element.style.display = 'flex';
                });
            }
            
            // Update DRY and XTC sliders specifically
            const drySliderContainer = elements.drySlider.closest('.setting-item');
            const xtcSliderContainer = elements.xtcSlider.closest('.setting-item');
            
            // Hide DRY and XTC if either Strict API is ON or LM Studio Endpoint is ON
            if (app.settings.strictApiEnabled || app.settings.lmStudioEndpointEnabled) {
                drySliderContainer.style.display = 'none';
                xtcSliderContainer.style.display = 'none';
            } else {
                drySliderContainer.style.display = 'flex';
                xtcSliderContainer.style.display = 'flex';
            }
            
            // Update Tokens to Suggest slider
            const tokensToSuggestContainer = elements.tokensToSuggestSlider.closest('.setting-item');
            
            if (app.settings.lmStudioEndpointEnabled) {
                tokensToSuggestContainer.style.display = 'flex';
            } else {
                tokensToSuggestContainer.style.display = 'none';
                hideCompletionSuggestion();
            }
        }

        /**
         * Applies interface settings and ensures parameter visibility is correct
         */
        function applyInterfaceSettings() {
            document.documentElement.style.setProperty('--chat-width', `${app.settings.chatWidth}%`);
            document.documentElement.style.setProperty('--text-size', `${app.settings.textSize}px`);
            
            elements.chatWidthSlider.value = app.settings.chatWidth;
            elements.chatWidthValue.value = app.settings.chatWidth;
            elements.textSizeSlider.value = app.settings.textSize;
            elements.textSizeValue.value = app.settings.textSize;
            
            elements.tokensToSuggestSlider.value = app.settings.tokensToSuggest;
            elements.tokensToSuggestValue.value = app.settings.tokensToSuggest;
            
            elements.webSearchAgentsSlider.value = app.settings.webSearchAgents;
            elements.webSearchAgentsValue.value = app.settings.webSearchAgents;
            
            elements.webSearchToggle.checked = app.settings.webSearchEnabled;
            elements.thinkingModelToggle.checked = app.settings.thinkingModelEnabled;
            elements.markdownColorCodingToggle.checked = app.settings.markdownColorCoding;
            elements.whiteThemeToggle.checked = app.settings.whiteTheme;
            elements.lmStudioEndpointToggle.checked = app.settings.lmStudioEndpointEnabled;
            elements.strictApiToggle.checked = app.settings.strictApiEnabled;
            
            if (app.settings.whiteTheme) {
                document.documentElement.classList.add('white-theme');
            } else {
                document.documentElement.classList.remove('white-theme');
            }
            
            // Update parameter visibility based on both switches
            updateParameterVisibility();
        }

        function updateSettingsUI() {
            elements.systemPromptTextarea.value = app.settings.systemPrompt;
            elements.tempSlider.value = app.settings.temperature;
            elements.tempValue.value = app.settings.temperature;
            elements.topkSlider.value = app.settings.topK;
            elements.topkValue.value = app.settings.topK;
            elements.repeatPenaltySlider.value = app.settings.repeatPenalty;
            elements.repeatPenaltyValue.value = app.settings.repeatPenalty;
            elements.minpSlider.value = app.settings.minP;
            elements.minpValue.value = app.settings.minP;
            elements.toppSlider.value = app.settings.topP;
            elements.toppValue.value = app.settings.topP;
            elements.maxTokensSlider.value = app.settings.maxTokens;
            elements.maxTokensValue.value = app.settings.maxTokens;
            elements.chatWidthSlider.value = app.settings.chatWidth;
            elements.chatWidthValue.value = app.settings.chatWidth;
            elements.textSizeSlider.value = app.settings.textSize;
            elements.textSizeValue.value = app.settings.textSize;
            elements.tokensToSuggestSlider.value = app.settings.tokensToSuggest;
            elements.tokensToSuggestValue.value = app.settings.tokensToSuggest;
            elements.webSearchAgentsSlider.value = app.settings.webSearchAgents;
            elements.webSearchAgentsValue.value = app.settings.webSearchAgents;
            elements.webSearchToggle.checked = app.settings.webSearchEnabled;
            elements.thinkingModelToggle.checked = app.settings.thinkingModelEnabled;
            elements.markdownColorCodingToggle.checked = app.settings.markdownColorCoding;
            elements.whiteThemeToggle.checked = app.settings.whiteTheme;
            elements.apiEndpointInput.value = app.settings.apiEndpoint;
            elements.apiKeyInput.value = app.settings.apiKey;
            elements.modelNameInput.value = app.settings.modelName;
            elements.drySlider.value = app.settings.dryMultiplier;
            elements.dryValue.value = app.settings.dryMultiplier;
            elements.xtcSlider.value = app.settings.xtcProbability;
            elements.xtcValue.value = app.settings.xtcProbability;
            elements.lmStudioEndpointToggle.checked = app.settings.lmStudioEndpointEnabled;
            elements.strictApiToggle.checked = app.settings.strictApiEnabled;
            
            updateParameterVisibility();
            
            // Update paste button state
            if (elements.pasteSettingsBtn) {
                elements.pasteSettingsBtn.disabled = !app.copiedSettings;
            }
        }

        function updateUISettings() {
            restoreSystemPromptHeight();
            
            if (app.uiSettings.systemPromptCollapsed) {
                elements.systemPromptSection.classList.add('collapsed');
            } else {
                elements.systemPromptSection.classList.remove('collapsed');
            }
            
            if (app.uiSettings.parametersCollapsed) {
                elements.parametersSection.classList.add('collapsed');
            } else {
                elements.parametersSection.classList.remove('collapsed');
            }
            
            if (app.uiSettings.interfaceCollapsed) {
                elements.interfaceSection.classList.add('collapsed');
            } else {
                elements.interfaceSection.classList.remove('collapsed');
            }
            
            if (app.uiSettings.apiSettingsCollapsed) {
                elements.apiSettingsSection.classList.add('collapsed');
            } else {
                elements.apiSettingsSection.classList.remove('collapsed');
            }
        }

        function saveSystemPromptHeight() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            // Only save height if the section is not collapsed
            if (elements.systemPromptSection.classList.contains('collapsed')) {
                return;
            }
            
            // Save the current height of the textarea
            const currentHeight = elements.systemPromptTextarea.offsetHeight;
            app.uiSettings.systemPromptHeight = currentHeight;
            
            // Check if the textarea is at its minimum size
            const minHeight = parseInt(window.getComputedStyle(elements.systemPromptTextarea).minHeight) || 100;
            app.uiSettings.systemPromptAtMinSize = currentHeight <= minHeight;
            
            chat.uiSettings = { ...app.uiSettings };
            saveChatsToStorage();
        }

        function restoreSystemPromptHeight() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            elements.systemPromptTextarea.value = app.settings.systemPrompt;
            
            // Always restore the saved height or use the default, even when collapsed
            if (chat.uiSettings && chat.uiSettings.systemPromptHeight) {
                elements.systemPromptTextarea.style.height = `${chat.uiSettings.systemPromptHeight}px`;
            } else {
                elements.systemPromptTextarea.style.height = '100px';
            }
            
            // Set a flag to indicate if we're at minimum size
            if (chat.uiSettings && chat.uiSettings.systemPromptAtMinSize) {
                elements.systemPromptTextarea.dataset.atMinSize = 'true';
            } else {
                elements.systemPromptTextarea.dataset.atMinSize = 'false';
            }
        }

        function checkIfAtMinSize() {
            // Don't check or save if the section is collapsed
            if (elements.systemPromptSection.classList.contains('collapsed')) {
                return;
            }
            
            const currentHeight = elements.systemPromptTextarea.offsetHeight;
            const minHeight = parseInt(window.getComputedStyle(elements.systemPromptTextarea).minHeight) || 100;
            
            // If we're at minimum size and weren't before, save this state
            if (currentHeight <= minHeight && elements.systemPromptTextarea.dataset.atMinSize !== 'true') {
                elements.systemPromptTextarea.dataset.atMinSize = 'true';
                saveSystemPromptHeight();
            }
            // If we're not at minimum size but were before, save this state
            else if (currentHeight > minHeight && elements.systemPromptTextarea.dataset.atMinSize === 'true') {
                elements.systemPromptTextarea.dataset.atMinSize = 'false';
                saveSystemPromptHeight();
            }
        }

        function saveUISettings() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            chat.uiSettings = { ...app.uiSettings };
            saveChatsToStorage();
        }

        // Model Selection Functions
        async function fetchAvailableModels() {
            if (app.modelSelection.isLoading) return;
            
            app.modelSelection.isLoading = true;
            
            try {
                const response = await fetch(`${app.settings.apiEndpoint}/models`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch models: ${response.status}`);
                }
                
                const data = await response.json();
                app.modelSelection.availableModels = data.data || [];
                populateModelDropdown();
            } catch (error) {
                console.error('Error fetching models:', error);
                app.modelSelection.availableModels = [];
            } finally {
                app.modelSelection.isLoading = false;
            }
        }

        function populateModelDropdown() {
            elements.modelDropdown.innerHTML = '';
            
            if (app.modelSelection.availableModels.length === 0) {
                const noModelsOption = document.createElement('div');
                noModelsOption.className = 'model-option';
                noModelsOption.textContent = 'No models available';
                elements.modelDropdown.appendChild(noModelsOption);
                return;
            }
            
            app.modelSelection.availableModels.forEach(model => {
                const modelOption = document.createElement('div');
                modelOption.className = 'model-option';
                modelOption.textContent = model.id;
                
                if (model.id === app.settings.modelName) {
                    modelOption.classList.add('selected');
                }
                
                modelOption.addEventListener('click', () => {
                    selectModel(model.id);
                });
                
                elements.modelDropdown.appendChild(modelOption);
            });
        }

        function selectModel(modelId) {
            app.settings.modelName = modelId;
            elements.modelNameInput.value = modelId;
            updateSettings();
            hideModelDropdown();
        }

        function showModelDropdown() {
            if (!app.modelSelection.isDropdownVisible) {
                fetchAvailableModels();
                app.modelSelection.isDropdownVisible = true;
                elements.modelDropdown.classList.add('visible');
            }
        }

        function hideModelDropdown() {
            app.modelSelection.isDropdownVisible = false;
            elements.modelDropdown.classList.remove('visible');
        }

        function filterModelDropdown(searchTerm) {
            const modelOptions = elements.modelDropdown.querySelectorAll('.model-option');
            
            modelOptions.forEach(option => {
                const modelName = option.textContent.toLowerCase();
                if (modelName.includes(searchTerm.toLowerCase())) {
                    option.style.display = 'block';
                } else {
                    option.style.display = 'none';
                }
            });
        }

        // Chat Functions
        function createNewChat() {
            if (app.isGenerating || app.webSearch.isSearching) return;
            
            const newChat = {
                id: generateId(),
                title: 'New Chat',
                messages: [],
                settings: { ...app.settings },
                uiSettings: { ...app.uiSettings },
                avatars: {
                    user: null,
                    llm: null
                },
                createdAt: new Date().toISOString(),
                groupId: null,
                settingsPanelWidth: 300,
                settingsPanelCollapsed: false
            };
            
            app.chats.unshift(newChat);
            saveChatsToStorage();
            renderChatsList();
            selectChat(newChat.id);
        }

        function createNewGroup() {
            if (app.isGenerating || app.webSearch.isSearching) return;
            
            const groupName = prompt('Enter group name:');
            if (!groupName || !groupName.trim()) return;
            
            const newGroup = {
                id: generateId(),
                name: groupName.trim(),
                collapsed: false
            };
            
            app.groups.push(newGroup);
            saveGroupsToStorage();
            renderChatsList();
        }

        function selectChat(chatId) {
            if (app.isGenerating || app.webSearch.isSearching) return;
            
            const chat = app.chats.find(c => c.id === chatId);
            if (!chat) return;
            
            app.currentChatId = chatId;
            saveLastSelectedChat();
            
            elements.dialogueTitle.textContent = chat.title;
            
            app.settings = { ...chat.settings };
            updateSettingsUI();
            
            applyInterfaceSettings();
            
            app.uiSettings = { ...app.uiSettings, ...(chat.uiSettings || {}) };
            updateUISettings();
            
            app.userScrolled = false;
            
            renderMessages();
            
            document.querySelectorAll('.chat-item').forEach(item => {
                item.classList.remove('active');
                item.classList.remove('active-in-collapsed-group');
                if (item.dataset.chatId === chatId) {
                    const parentGroup = item.closest('.chat-group');
                    if (parentGroup && parentGroup.classList.contains('collapsed')) {
                        item.classList.add('active-in-collapsed-group');
                    } else {
                        item.classList.add('active');
                    }
                }
            });
            
            updateSendButton();
            
            setTimeout(syncSendButtonHeight, 50);
            
            applyPanelSettings();
            
            // Always scroll to bottom when loading a chat
            scrollToBottom(true);
        }

        function renderChatsList() {
            elements.chatsList.innerHTML = '';
            
            app.groups.forEach(group => {
                const groupElement = createGroupElement(group);
                elements.chatsList.appendChild(groupElement);
            });
            
            const ungroupedChats = app.chats.filter(chat => !chat.groupId);
            if (ungroupedChats.length > 0) {
                const ungroupedSection = document.createElement('div');
                ungroupedSection.className = 'ungrouped-section';
                
                const ungroupedHeader = document.createElement('div');
                ungroupedHeader.className = 'ungrouped-header';
                ungroupedHeader.textContent = 'Ungrouped';
                ungroupedSection.appendChild(ungroupedHeader);
                
                ungroupedChats.forEach(chat => {
                    const chatItem = createChatItemElement(chat);
                    ungroupedSection.appendChild(chatItem);
                });
                
                elements.chatsList.appendChild(ungroupedSection);
            }
        }

        function createGroupElement(group) {
            const groupElement = document.createElement('div');
            groupElement.className = 'chat-group';
            if (group.collapsed) {
                groupElement.classList.add('collapsed');
            }
            
            if (app.isGenerating || app.webSearch.isSearching) {
                groupElement.classList.add('locked');
            }
            
            groupElement.dataset.groupId = group.id;
            
            const groupHeader = document.createElement('div');
            groupHeader.className = 'chat-group-header';
            
            const groupTitle = document.createElement('div');
            groupTitle.className = 'chat-group-title';
            groupTitle.textContent = group.name;
            
            const groupActions = document.createElement('div');
            groupActions.className = 'chat-group-actions';
            
            const renameBtn = document.createElement('button');
            renameBtn.className = 'chat-action-btn';
            renameBtn.title = 'Rename';
            renameBtn.textContent = '‚úèÔ∏è';
            renameBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    renameGroup(group.id);
                }
            });
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'chat-action-btn';
            deleteBtn.title = 'Delete';
            deleteBtn.textContent = 'üóëÔ∏è';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    deleteGroup(group.id);
                }
            });
            
            groupActions.appendChild(renameBtn);
            groupActions.appendChild(deleteBtn);
            
            groupHeader.appendChild(groupTitle);
            groupHeader.appendChild(groupActions);
            
            groupHeader.addEventListener('click', () => {
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    toggleGroupCollapse(group.id);
                }
            });
            
            const groupContent = document.createElement('div');
            groupContent.className = 'chat-group-content';
            
            const groupChats = app.chats.filter(chat => chat.groupId === group.id);
            groupChats.forEach(chat => {
                const chatItem = createChatItemElement(chat);
                groupContent.appendChild(chatItem);
            });
            
            groupElement.appendChild(groupHeader);
            groupElement.appendChild(groupContent);
            
            return groupElement;
        }

        function createChatItemElement(chat) {
            const chatItem = document.createElement('div');
            chatItem.className = 'chat-item';
            chatItem.dataset.chatId = chat.id;
            
            if (app.isGenerating || app.webSearch.isSearching) {
                chatItem.classList.add('locked');
            }
            
            if (chat.id === app.currentChatId) {
                const parentGroup = chatItem.closest('.chat-group');
                if (parentGroup && parentGroup.classList.contains('collapsed')) {
                    chatItem.classList.add('active-in-collapsed-group');
                } else {
                    chatItem.classList.add('active');
                }
            }
            
            const date = new Date(chat.createdAt);
            const formattedDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            chatItem.innerHTML = `
                <div class="chat-item-title">${chat.title}</div>
                <div class="chat-item-date">${formattedDate}</div>
                <div class="chat-item-actions">
                    <button class="chat-action-btn" title="Copy">üìã</button>
                    <button class="chat-action-btn" title="Rename">‚úèÔ∏è</button>
                    <button class="chat-action-btn" title="Move to Group">üìÅ</button>
                    <button class="chat-action-btn clean-chat" title="Clean Chat History">üßπ</button>
                    <button class="chat-action-btn delete-chat" title="Delete">üóëÔ∏è</button>
                </div>
            `;
            
            chatItem.addEventListener('click', (e) => {
                if (!e.target.classList.contains('chat-action-btn') && !app.isGenerating && !app.webSearch.isSearching) {
                    selectChat(chat.id);
                }
            });
            
            chatItem.querySelector('.chat-action-btn[title="Copy"]').addEventListener('click', (e) => {
                e.stopPropagation();
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    copyChat(chat.id);
                }
            });
            
            chatItem.querySelector('.chat-action-btn[title="Rename"]').addEventListener('click', (e) => {
                e.stopPropagation();
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    renameChat(chat.id);
                }
            });
            
            chatItem.querySelector('.chat-action-btn[title="Move to Group"]').addEventListener('click', (e) => {
                e.stopPropagation();
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    openGroupSelectionModal(chat.id);
                }
            });
            
            chatItem.querySelector('.chat-action-btn.clean-chat').addEventListener('click', (e) => {
                e.stopPropagation();
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    cleanChatHistory(chat.id);
                }
            });
            
            chatItem.querySelector('.chat-action-btn.delete-chat').addEventListener('click', (e) => {
                e.stopPropagation();
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    deleteChat(chat.id);
                }
            });
            
            return chatItem;
        }

        function cleanChatHistory(chatId) {
            const chat = app.chats.find(c => c.id === chatId);
            if (!chat) return;
            
            if (confirm('Are you sure you want to clean the chat history? This will remove all messages but keep the chat itself.')) {
                chat.messages = [];
                saveChatsToStorage();
                
                if (app.currentChatId === chatId) {
                    renderMessages();
                }
            }
        }

        function toggleGroupCollapse(groupId) {
            const group = app.groups.find(g => g.id === groupId);
            if (!group) return;
            
            group.collapsed = !group.collapsed;
            saveGroupsToStorage();
            renderChatsList();
        }

        function renameGroup(groupId) {
            const group = app.groups.find(g => g.id === groupId);
            if (!group) return;
            
            const newName = prompt('Enter new group name:', group.name);
            if (newName && newName.trim()) {
                group.name = newName.trim();
                saveGroupsToStorage();
                renderChatsList();
            }
        }

        function deleteGroup(groupId) {
            const groupIndex = app.groups.findIndex(g => g.id === groupId);
            if (groupIndex === -1) return;
            
            if (confirm('Are you sure you want to delete this group? All chats in this group will be moved to ungrouped.')) {
                app.chats.forEach(chat => {
                    if (chat.groupId === groupId) {
                        chat.groupId = null;
                    }
                });
                
                app.groups.splice(groupIndex, 1);
                
                saveGroupsToStorage();
                saveChatsToStorage();
                renderChatsList();
            }
        }

        function copyChat(chatId) {
            const chat = app.chats.find(c => c.id === chatId);
            if (!chat) return;
    
            const newChat = {
                ...chat,
                id: generateId(),
                title: `${chat.title} (Copy)`,
                createdAt: new Date().toISOString()
            };
    
            app.chats.unshift(newChat);
            saveChatsToStorage();
            renderChatsList();
    
            selectChat(newChat.id);
    
            setTimeout(() => {
                window.location.reload();
            }, 100);
        }

        function renameChat(chatId) {
            const chat = app.chats.find(c => c.id === chatId);
            if (!chat) return;
            
            const newTitle = prompt('Enter new chat title:', chat.title);
            if (newTitle && newTitle.trim()) {
                chat.title = newTitle.trim();
                saveChatsToStorage();
                renderChatsList();
                
                if (app.currentChatId === chatId) {
                    elements.dialogueTitle.textContent = chat.title;
                }
            }
        }

        function deleteChat(chatId) {
            const index = app.chats.findIndex(c => c.id === chatId);
            if (index === -1) return;
            
            if (confirm('Are you sure you want to delete this chat?')) {
                app.chats.splice(index, 1);
                saveChatsToStorage();
                renderChatsList();
                
                if (app.currentChatId === chatId) {
                    if (app.chats.length > 0) {
                        selectChat(app.chats[0].id);
                    } else {
                        app.currentChatId = null;
                        elements.dialogueTitle.textContent = 'Select a chat or create a new one';
                        elements.chatContainer.innerHTML = '';
                        updateSendButton();
                        localStorage.removeItem('llm-last-selected-chat');
                    }
                }
            }
        }

        // Message Functions
        function renderMessages(scrollToBottomAfterRender = true) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            elements.chatContainer.innerHTML = '';
            
            chat.messages.forEach(message => {
                addMessageToDOM(message);
            });
            
            updateMessageActionButtons(app.isGenerating || app.webSearch.isSearching);
            updateContinueButtonsState();
            
            if (scrollToBottomAfterRender && !app.isGenerating && !app.webSearch.isSearching) {
                scrollToBottom();
            }
        }

        function addMessageToDOM(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.role}`;
            if (message.ignored) {
                messageDiv.classList.add('ignored');
            }
            messageDiv.dataset.messageId = message.id;
            
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            
            if (message.role === 'assistant') {
                avatarDiv.classList.add('ai-avatar');
            }
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (chat && chat.avatars[message.role]) {
                avatarDiv.innerHTML = `<img src="${chat.avatars[message.role]}" alt="${message.role} avatar">`;
            } else {
                avatarDiv.textContent = message.role === 'user' ? 'U' : 'LLM';
            }
            
            avatarDiv.addEventListener('click', () => {
                openAvatarUpload(message.role);
            });
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            const textDiv = document.createElement('div');
            textDiv.className = 'message-text';
            
            // Check if message is ignored
            if (message.ignored) {
                // For ignored messages, make text non-editable and show only 2 lines
                textDiv.contentEditable = false;
                
                // Get the first 2 lines of the message
                const lines = message.content.split('\n');
                const previewText = lines.slice(0, 2).join('\n');
                
                // Add indicator if there's more content
                const displayText = lines.length > 2 ? previewText + '\n...' : previewText;
                
                textDiv.innerHTML = applyMarkdownHighlighting(displayText);
                
                // Add a title attribute to show the full content on hover
                textDiv.title = message.content;
            } else {
                // For non-ignored messages, keep the original behavior
                textDiv.contentEditable = true;
                textDiv.innerHTML = applyMarkdownHighlighting(message.content);
                
                let isEditing = false;
                
                textDiv.addEventListener('focus', () => {
                    isEditing = true;
                    app.textCompletion.editingMessageId = message.id;
                    app.textCompletion.editingElement = textDiv;
                    app.textCompletion.lastCursorPosition = 0;
                });
                
                textDiv.addEventListener('blur', () => {
                    isEditing = false;
                    app.textCompletion.editingMessageId = null;
                    app.textCompletion.editingElement = null;
                    
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = textDiv.innerHTML;
                    
                    let plainText = '';
                    const childNodes = Array.from(tempDiv.childNodes);
                    
                    childNodes.forEach((node, index) => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            plainText += node.textContent;
                        } else if (node.nodeName === 'BR') {
                            plainText += '\n';
                        } else if (node.nodeName === 'DIV') {
                            plainText += node.textContent;
                            if (index < childNodes.length - 1) {
                                plainText += '\n';
                            }
                        } else {
                            plainText += node.textContent;
                        }
                    });
                    
                    updateMessageContent(message.id, plainText);
                    
                    textDiv.innerHTML = applyMarkdownHighlighting(plainText);
                });
                
                textDiv.addEventListener('click', () => {
                    if (isEditing) {
                        handleCursorPositionChangeInMessage(textDiv);
                    }
                });
                
                textDiv.addEventListener('keyup', () => {
                    if (isEditing) {
                        handleCursorPositionChangeInMessage(textDiv);
                    }
                });
                
                textDiv.addEventListener('input', () => {
                    if (!isEditing) return;
                    
                    handleTextCompletionInput(message.id, textDiv);
                });
                
                textDiv.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.execCommand('insertLineBreak', false, null);
                        return false;
                    }
                    
                    if (e.key === 'Tab' && app.textCompletion.currentSuggestion) {
                        e.preventDefault();
                        if (checkCursorPositionChanged()) {
                            hideCompletionSuggestion();
                        } else {
                            if (message.role === 'user') {
                                handleTabKeyForUserMessage(message.id, textDiv);
                            } else if (message.role === 'assistant') {
                                handleTabKeyForLLMMessage(textDiv);
                            }
                        }
                    }
                });
            }
            
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            
            if (message.role === 'user') {
                // Modified: Moved ignore button to be before copy button
                actionsDiv.innerHTML = `
                    <button class="message-action-btn react-message" title="React / Search">‚ö°</button>
                    <button class="message-action-btn ignore-message" title="Ignore">üö´</button>
                    <button class="message-action-btn copy-message" title="Copy">üìã</button>
                    <button class="message-action-btn delete-message" title="Delete">üóëÔ∏è</button>
                `;
            } else {
                // Modified: Moved ignore button to be before copy button
                actionsDiv.innerHTML = `
                    <button class="message-action-btn regenerate-message" title="Regenerate (N/A Search)">üîÑ</button>
                    <button class="message-action-btn continue-message" title="Continue (N/A Search)">‚ûï</button>
                    <button class="message-action-btn ignore-message" title="Ignore">üö´</button>
                    <button class="message-action-btn copy-message" title="Copy">üìã</button>
                    <button class="message-action-btn delete-message" title="Delete">üóëÔ∏è</button>
                `;
            }
            
            contentDiv.appendChild(textDiv);
            contentDiv.appendChild(actionsDiv);
            
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentDiv);
            
            const ignoreBtn = actionsDiv.querySelector('.ignore-message');
            const regenerateBtn = actionsDiv.querySelector('.regenerate-message');
            const continueBtn = actionsDiv.querySelector('.continue-message');
            const reactBtn = actionsDiv.querySelector('.react-message');
            
            // Modified: Keep buttons active for ignored messages, but still disable during generation
            if (ignoreBtn) {
                ignoreBtn.disabled = app.isGenerating || app.webSearch.isSearching;
                if (message.ignored) {
                    ignoreBtn.textContent = '‚úÖ';
                    ignoreBtn.title = 'Unignore';
                }
            }
            if (regenerateBtn) regenerateBtn.disabled = app.isGenerating || app.webSearch.isSearching;
            if (continueBtn) continueBtn.disabled = app.isGenerating || app.webSearch.isSearching || app.settings.thinkingModelEnabled || !app.settings.lmStudioEndpointEnabled;
            if (reactBtn) reactBtn.disabled = app.isGenerating || app.webSearch.isSearching;
            
            actionsDiv.querySelector('.copy-message')?.addEventListener('click', () => {
                // For ignored messages, copy the full content, not just the preview
                const textToCopy = message.ignored ? message.content : (textDiv.textContent || textDiv.innerText || '');
                copyToClipboard(textToCopy);
            });
            
            actionsDiv.querySelector('.delete-message')?.addEventListener('click', () => {
                deleteMessage(message.id);
            });
            
            actionsDiv.querySelector('.regenerate-message')?.addEventListener('click', () => {
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    regenerateMessage(message.id);
                }
            });
            
            actionsDiv.querySelector('.continue-message')?.addEventListener('click', () => {
                if (!app.isGenerating && !app.webSearch.isSearching && !app.settings.thinkingModelEnabled && app.settings.lmStudioEndpointEnabled) {
                    continueMessage(message.id);
                }
            });
            
            actionsDiv.querySelector('.react-message')?.addEventListener('click', () => {
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    reactToMessage(message.id);
                }
            });
            
            ignoreBtn?.addEventListener('click', () => {
                if (!app.isGenerating && !app.webSearch.isSearching) {
                    toggleIgnoreMessage(message.id);
                }
            });
            
            elements.chatContainer.appendChild(messageDiv);
        }

        function toggleIgnoreMessage(messageId) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const message = chat.messages.find(m => m.id === messageId);
            if (!message) return;
            
            // Toggle the ignored state
            message.ignored = !message.ignored;
            saveChatsToStorage();
            
            // Re-render the messages to apply the new state
            renderMessages();
        }

        function getMessagesForLLM() {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return [];
            
            let messages = [];
            
            if (app.settings.systemPrompt) {
                messages.push({
                    role: 'system',
                    content: app.settings.systemPrompt
                });
            }
            
            // Filter out ignored messages
            const filteredMessages = chat.messages.filter(m => !m.ignored);
            
            messages = messages.concat(
                filteredMessages.map(m => ({ role: m.role, content: m.content }))
            );
            
            return messages;
        }

        function handleCursorPositionChangeInMessage(element) {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(element);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                const currentCursorPosition = preCaretRange.toString().length;
                
                if (currentCursorPosition !== app.textCompletion.lastCursorPosition) {
                    app.textCompletion.lastCursorPosition = currentCursorPosition;
                    
                    if (app.textCompletion.currentSuggestion) {
                        hideCompletionSuggestion();
                    }
                }
            }
        }

        /**
         * Update message in DOM with proper scrolling behavior
         * @param {string} messageId - ID of the message to update
         * @param {string} content - New content for the message
         * @param {boolean} isContinuation - Whether this is a continuation of an existing message
         */
        function updateMessageInDOM(messageId, content, isContinuation = false) {
            const messageElement = document.querySelector(`.message[data-message-id="${messageId}"] .message-text`);
            if (messageElement) {
                const isEditing = messageElement === document.activeElement;
                
                if (!isEditing) {
                    messageElement.innerHTML = applyMarkdownHighlighting(content);
                } else {
                    messageElement.textContent = content;
                }
                
                if (isContinuation) {
                    // For message continuation, only scroll if user was at bottom when generation started
                    if (app.wasAtBottomBeforeGeneration) {
                        scrollToBottom();
                    }
                } else {
                    // For new content, scroll if appropriate
                    scrollToBottom();
                }
            }
        }

        function updateMessageContent(messageId, newContent) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const message = chat.messages.find(m => m.id === messageId);
            if (message) {
                message.content = newContent;
                saveChatsToStorage();
            }
        }

        function deleteMessage(messageId) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const index = chat.messages.findIndex(m => m.id === messageId);
            if (index !== -1) {
                chat.messages.splice(index, 1);
                saveChatsToStorage();
                renderMessages();
            }
        }

        // API Functions
        async function fetchWithRetry(url, options, maxRetries = 5, retryDelay = 2000) {
            let lastError;
            let attempt = 0;
            let isServerBusy = false;
            
            while (true) {
                try {
                    const response = await fetch(url, options);
                    
                    // If the response is successful, return it
                    if (response.ok) {
                        // If we were previously showing the busy status, update to connected
                        if (isServerBusy) {
                            updateAPIStatus('connected');
                            isServerBusy = false;
                        }
                        return response;
                    }
                    
                    // If we get a 503 error (server busy), retry indefinitely with 2-second delay
                    if (response.status === 503 || response.status === 429) {
                        lastError = new Error(`Server busy (503), waiting...`);
                        console.log(lastError.message);
                        
                        // Update the status to show server is busy (only once)
                        if (!isServerBusy) {
                            updateAPIStatus('busy');
                            isServerBusy = true;
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 2000)); // 2-second delay for 503
                        continue; // Continue the loop for infinite retry
                    }
                    
                    // For other error statuses, use the existing retry system
                    lastError = new Error(`API request failed with status ${response.status}`);
                    
                    // If we were previously showing the busy status, update to error
                    if (isServerBusy) {
                        updateAPIStatus('error');
                        isServerBusy = false;
                    }
                    
                    // If this is the last attempt, throw the error
                    if (attempt >= maxRetries) {
                        throw lastError;
                    }
                    
                    // Wait before retrying
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    attempt++;
                } catch (error) {
                    lastError = error;
                    
                    // If we were previously showing the busy status, update to error
                    if (isServerBusy) {
                        updateAPIStatus('error');
                        isServerBusy = false;
                    }
                    
                    // If this is the last attempt, throw the error
                    if (attempt >= maxRetries) {
                        throw lastError;
                    }
                    
                    // Wait before retrying
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    attempt++;
                }
            }
            
            // This should never be reached, but just in case
            throw lastError;
        }

        /**
         * Logs an API event with timestamp and details
         * @param {string} event - The event type (e.g., 'start', 'success', 'error', 'retry')
         * @param {string} details - Details about the event
         * @param {Object} data - Additional data to log (optional)
         */
        function logApiEvent(event, details, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp,
                event,
                details,
                data
            };
            
            app.webSearch.debug.apiLog.push(logEntry);
            
            // Update debug window in real-time if it's visible
            if (elements.debugWindow.classList.contains('visible')) {
                updateDebugWindow();
            }
        }

        // Retry function specifically for DuckDuckGo API requests with logging
        async function fetchDuckDuckGoWithRetry(url, options) {
            const maxRetries = 5;
            const retryDelay = 1000;
            const timeoutMs = 15000; // N second timeout to prevent hanging
            let lastError;
            
            logApiEvent('start', `Starting DuckDuckGo API request to: ${url}`);
            
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    if (attempt > 0) {
                        logApiEvent('retry', `Retry attempt ${attempt}/${maxRetries - 1} after ${retryDelay}ms delay`);
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                    }
                    
                    logApiEvent('fetch', `Sending fetch request (attempt ${attempt + 1}/${maxRetries})`);
                    const startTime = performance.now();
                    
                    // Create a timeout promise that will reject after timeoutMs
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs}ms`)), timeoutMs);
                    });
                    
                    // Race the fetch request against the timeout
                    const response = await Promise.race([
                        fetch(url, options),
                        timeoutPromise
                    ]);
                    
                    const endTime = performance.now();
                    const responseTime = Math.round(endTime - startTime);
                    
                    // If the response is successful, return it
                    if (response.ok) {
                        logApiEvent('success', `API request successful in ${responseTime}ms`, {
                            status: response.status,
                            statusText: response.statusText,
                            responseTime
                        });
                        return response;
                    }
                    
                    // For any error status, create an error and retry
                    lastError = new Error(`DuckDuckGo API request failed with status ${response.status}`);
                    
                    logApiEvent('error', `API request failed (attempt ${attempt + 1}/${maxRetries})`, {
                        status: response.status,
                        statusText: response.statusText,
                        responseTime,
                        willRetry: attempt < maxRetries - 1
                    });
                    
                    // If this is the last attempt, throw the error
                    if (attempt === maxRetries - 1) {
                        logApiEvent('failed', `All ${maxRetries} attempts failed, giving up`);
                        throw lastError;
                    }
                } catch (error) {
                    lastError = error;
                    
                    // Check if it's a timeout error
                    const isTimeout = error.message.includes('Timed Out');
                    
                    logApiEvent('error', `API request error (attempt ${attempt + 1}/${maxRetries})`, {
                        error: error.message,
                        isTimeout: isTimeout,
                        willRetry: attempt < maxRetries - 1
                    });
                    
                    // If this is the last attempt, throw the error
                    if (attempt === maxRetries - 1) {
                        logApiEvent('failed', `All ${maxRetries} attempts failed, giving up`);
                        throw lastError;
                    }
                }
            }
            
            // This should never be reached, but just in case
            throw lastError;
        }

        function cleanThinkingModelResponse(text) {
            // Add <think01> to the start of the text if not already present
            if (!text.startsWith('<think>')) {
                text = '<think>' + text;
            }
            
            const markerPatterns = [
                { start: '<think>', end: '</think>' },
                { start: '[THINK]', end: '[/THINK]' }
            ];
            
            let cleanedText = text;
            
            for (const pattern of markerPatterns) {
                const startIndex = cleanedText.indexOf(pattern.start);
                const endIndex = cleanedText.indexOf(pattern.end);
                
                if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                    cleanedText = 
                        cleanedText.substring(0, startIndex) + 
                        cleanedText.substring(endIndex + pattern.end.length);
                }
            }
            
            // Delete a single  tag from the start of the text
            if (cleanedText.startsWith('<think>')) {
                cleanedText = cleanedText.substring(7);
            }
            
            const lines = cleanedText.split('\n');
            
            let firstNonEmptyLineIndex = 0;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim() !== '') {
                    firstNonEmptyLineIndex = i;
                    break;
                }
            }
            
            if (firstNonEmptyLineIndex > 0) {
                cleanedText = lines.slice(firstNonEmptyLineIndex).join('\n');
            }
            
            return cleanedText;
        }

        function processThinkingModelResponse(messageId) {
            if (!app.thinkingModel.isProcessing || !app.thinkingModel.messageId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const message = chat.messages.find(m => m.id === app.thinkingModel.messageId);
            if (!message) return;
            
            let content = '';
            try {
                const jsonResponse = JSON.parse(app.thinkingModel.buffer);
                content = jsonResponse.choices[0]?.message?.content || '';
            } catch (e) {
                content = app.thinkingModel.buffer;
            }
            
            // Add <think01> to the start of the content
            content = '<think>' + content;
            
            // Clean the thinking model response
            const cleanedContent = cleanThinkingModelResponse(content);
            
            message.content = cleanedContent;
            saveChatsToStorage();
            
            // Update the message in DOM with the cleaned content
            updateMessageInDOM(message.id, cleanedContent);
            
            app.thinkingModel.buffer = '';
            app.thinkingModel.isProcessing = false;
            app.thinkingModel.messageId = null;
        }

        // Message Generation Functions
        async function sendMessage() {
            const content = elements.dialogueInput.value.trim();
            if (!content || !app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            // Track if user was at bottom before sending message
            const wasAtBottom = isAtBottom();
            
            const userMessage = {
                id: generateId(),
                role: 'user',
                content: content,
                timestamp: new Date().toISOString()
            };
            
            chat.messages.push(userMessage);
            saveChatsToStorage();
            addMessageToDOM(userMessage);
            
            elements.dialogueInput.value = '';
            elements.dialogueInput.style.height = 'auto';
            
            syncSendButtonHeight();
            updateSendButton();
            
            // Always scroll to bottom after sending a message
            scrollToBottom(true);
            
            if (app.settings.webSearchEnabled) {
                await performMultiPhaseWebSearch(content);
            } else {
                await generateLLMResponse();
            }
        }

        async function performMultiPhaseWebSearch(userMessage) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const agentsCount = app.settings.webSearchAgents;
            let allSearchSummaries = [];
            
            // Clear previous API log
            app.webSearch.debug.apiLog = [];
            logApiEvent('info', `Starting multi-phase web search with ${agentsCount} agents`);
            
            // Get last non-ignored message for context
            let lastMessage = '';
            const nonIgnoredMessages = chat.messages.filter(m => !m.ignored);
            if (nonIgnoredMessages.length > 1) {
                lastMessage = nonIgnoredMessages[nonIgnoredMessages.length - 2].content;
            }
            
            try {
                app.isGenerating = true;
                updateSendButton();
                
                for (let phase = 1; phase <= agentsCount; phase++) {
                    logApiEvent('phase', `Starting search phase ${phase}/${agentsCount}`);
                    
                    showSearchStatus(`Search Agent ${phase}/${agentsCount}: Generating search query...`);
                    
                    const searchGoal = app.webSearch.searchGoals[phase - 1];
                    
                    const searchQuery = await generateSearchQueryForPhase(userMessage, lastMessage, searchGoal, phase);
                    
                    app.webSearch.debug.searchQuery = searchQuery;
                    updateDebugWindow();
                    
                    showSearchStatus(`Search Agent ${phase}/${agentsCount}: ${searchQuery}`);
                    
                    try {
                        const searchResults = await performWebSearch(searchQuery);
                        
                        app.webSearch.debug.rawResults = searchResults;
                        updateDebugWindow();
                        
                        const hasNoInfoResult = searchResults.some(result => 
                            result.snippet && result.snippet.includes("No additional information found for")
                        );
                        
                        if (hasNoInfoResult) {
                            logApiEvent('info', `Search Agent ${phase}: Found "No additional information found for" in results. Aborting this phase.`);
                            console.log(`Search Agent ${phase}: Found "No additional information found for" in results. Aborting this phase.`);
                            continue;
                        }
                        
                        showSearchStatus(`Search Agent ${phase}/${agentsCount}: Processing search results...`);
                        
                        const searchSummary = await summarizeSearchResults(searchResults);
                        
                        allSearchSummaries.push(searchSummary);
                        
                        app.webSearch.debug.llmSummary = searchSummary;
                        updateDebugWindow();
                    } catch (searchError) {
                        logApiEvent('error', `Search Agent ${phase} failed: ${searchError.message}`);
                        console.error(`Search Agent ${phase} failed after retries:`, searchError);
                        // Continue to the next phase even if this one fails
                        continue;
                    }
                }
                
                logApiEvent('complete', `Multi-phase web search completed with ${allSearchSummaries.length} successful phases`);
                hideSearchStatus();
                
                const combinedSummaries = allSearchSummaries.join('\n\n---\n\n');
                
                await generateLLMResponseWithSearchContext(combinedSummaries);
            } catch (error) {
                logApiEvent('failed', `Multi-phase web search failed: ${error.message}`);
                console.error('Error in multi-phase web search process:', error);
                
                hideSearchStatus();
                
                await generateLLMResponse();
            } finally {
                app.isGenerating = false;
                updateSendButton();
            }
        }

        async function generateSearchQueryForPhase(userMessage, lastMessage, searchGoal, phase) {
            try {
                let prompt = `You are a search assistant that generates concise search queries for specific research phases. 
                Based on the following User Command Message and Context Message, create a short search phrase (3-9 words) that would be most effective for finding information related to the specified search goal. Use plain text, avoid markdown. Start your answer with SEARCH:.
                
                Context Message (SEARCH CONTEXT): "${lastMessage}"
                User Command Message (SEARCH COMMAND): "${userMessage}"
                `;
                
                if (searchGoal) {
                    prompt += `
                CURRENT SEARCH GOAL: ${searchGoal}
                `;
                }
                
                prompt += `
                Search query:`;
                
                const chat = app.chats.find(c => c.id === app.currentChatId);
                const isThinkingModelEnabled = chat ? chat.settings.thinkingModelEnabled : false;
                
                // Set max_tokens based on Thinking Model setting
                const maxTokens = isThinkingModelEnabled ? 8192 : 15;
                
                const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                    },
                    body: JSON.stringify(buildApiRequestBody([
                        { role: 'system', content: 'You are a search assistant that generates concise search queries for specific research phases.' },
                        { role: 'user', content: prompt }
                    ], {
                        temperature: 1,
                        max_tokens: maxTokens
                    }))
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                let query = '';
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        if (line.startsWith('data: ')) {
                            const data = line.substring(6);
                            if (data === '[DONE]') continue;
                            
                            try {
                                const json = JSON.parse(data);
                                const content = json.choices[0]?.delta?.content || '';
                                if (content) {
                                    query += content;
                                }
                            } catch (e) {
                                console.error('Error parsing JSON:', e);
                            }
                        }
                    }
                }
                
                // Clean the thinking model response
                if (isThinkingModelEnabled) {
                    query = cleanThinkingModelResponse(query);
                }
                
                return query.replace(/^["']|["']$/g, '').trim();
            } catch (error) {
                console.error('Error generating search query for phase:', error);
                return userMessage;
            }
        }

        function updateDebugWindow() {
            elements.debugSearchQuery.textContent = app.webSearch.debug.searchQuery;
            elements.debugRawResults.textContent = JSON.stringify(app.webSearch.debug.rawResults, null, 2);
            elements.debugLlmSummary.textContent = app.webSearch.debug.llmSummary;
            
            // Display both API logs and system message
            let debugContent = '';
            
            // First, add API logs if they exist
            if (app.webSearch.debug.apiLog && app.webSearch.debug.apiLog.length > 0) {
                const logEntries = app.webSearch.debug.apiLog.map(entry => {
                    let logLine = `[${entry.timestamp}] ${entry.event.toUpperCase()}: ${entry.details}`;
                    
                    if (entry.data) {
                        if (entry.data.responseTime) {
                            logLine += ` (${entry.data.responseTime}ms)`;
                        }
                        if (entry.data.status) {
                            logLine += ` [Status: ${entry.data.status}]`;
                        }
                        if (entry.data.error) {
                            logLine += ` [Error: ${entry.data.error}]`;
                        }
                    }
                    
                    return logLine;
                }).join('\n');
                
                debugContent += '=== LOG ===\n\n' + logEntries + '\n\n';
            }
            
            // Then, add the system message with search context
            debugContent += '=== SYSTEM MESSAGE WITH SEARCH CONTEXT ===\n\n' + (app.webSearch.debug.systemMessage || '');
            
            elements.debugSystemMessage.textContent = debugContent;
        }

        // Perform web search using DuckDuckGo API with retry logic and results processing timeout
        async function performWebSearch(query, retryCount = 0) {
            try {
                logApiEvent('search', `Performing web search for query: "${query}"`);
                
                // Only use the allorigins.win proxy for DuckDuckGo searches
                const proxyUrl = `http://127.0.0.1:1458/raw?url=${encodeURIComponent(`http://duckduckgo.com/html/?q=${encodeURIComponent(query)}?nocache=${Date.now()}`)}`;
                
                try {
                    logApiEvent('proxy', `Using proxy search for results`);
                    const htmlResponse = await fetchDuckDuckGoWithRetry(proxyUrl);
                    
                    if (htmlResponse.ok) {
                        // Create a timeout promise that will reject after timeoutMs
                        // This timeout is only started after a successful connection (Status: 200)
                        const resultsProcessingTimeout = new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('Results processing Timed Out')), 2000);
                        });
                        
                        // Create a promise for processing the results
                        const processResultsPromise = (async () => {
                            const htmlText = await htmlResponse.text();
                            
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(htmlText, 'text/html');
                            
                            const resultElements = doc.querySelectorAll('.result');
                            const results = [];
                            
                            for (let i = 0; i < resultElements.length && results.length < 10; i++) {
                                const resultElement = resultElements[i];
                                const titleElement = resultElement.querySelector('.result__a');
                                const snippetElement = resultElement.querySelector('.result__snippet');
                                
                                if (titleElement && snippetElement) {
                                    results.push({
                                        title: titleElement.textContent.trim(),
                                        url: titleElement.href,
                                        snippet: snippetElement.textContent.trim()
                                    });
                                }
                            }
                            
                            return { results, resultElementsCount: resultElements.length };
                        })();
                        
                        // Race the results processing against the timeout
                        // If processing takes longer than N seconds, the timeout will win
                        const { results, resultElementsCount } = await Promise.race([processResultsPromise, resultsProcessingTimeout]);
                        
                        logApiEvent('proxy', `Proxy search returned ${resultElementsCount} results, extracted ${results.length}`);
                        
                        // If we got results from the proxy, return them
                        if (results.length > 0) {
                            logApiEvent('complete', `Web search completed with ${results.length} results`);
                            return results;
                        }
                    }
                } catch (error) {
                    // Check if it's a timeout error for results processing
                    if (error.message.includes('Results processing Timed Out')) {
                        logApiEvent('timeout', `Results processing Timed Out`);
                        console.error('Results processing Timed Out');
                        
                        // Instead of falling back, retry the search with a modified query
                        // Limit the number of retries to prevent infinite loops
                        if (retryCount < 5) {
                            // Array of unique extension words to append to the query
                            const extensionWords = ['info', 'overview', 'facts', 'details', 'data'];
                            const extensionWord = extensionWords[retryCount];
                            
                            // Create a new query with the extension word
                            const modifiedQuery = `${query} ${extensionWord}`;
                            
                            logApiEvent('retry', `Retrying search (attempt ${retryCount + 1}/5) with modified query: "${modifiedQuery}"`);
                            return await performWebSearch(modifiedQuery, retryCount + 1);
                        } else {
                            logApiEvent('retry_limit', `Maximum retry attempts reached for query: "${query}"`);
                            console.error('Maximum retry attempts reached for web search');
                        }
                    } else {
                        logApiEvent('proxy_error', `Proxy search failed: ${error.message}`);
                        console.error('Error with proxy search:', error);
                    }
                }
                
                // If proxy search failed or returned no results, create fallback results
                logApiEvent('fallback', `Creating fallback results for query: "${query}"`);
                const fallbackResults = [];
                
                for (let i = 0; i < 10; i++) {
                    fallbackResults.push({
                        title: `Search result ${i + 1}`,
                        url: `https://duckduckgo.com/?q=${encodeURIComponent(query)}`,
                        snippet: `No additional information found for "${query}".`
                    });
                }
                
                logApiEvent('complete', `Web search completed with ${fallbackResults.length} fallback results`);
                return fallbackResults;
            } catch (error) {
                logApiEvent('failed', `Web search failed: ${error.message}`);
                console.error('Error performing web search:', error);
                
                return [
                    {
                        title: 'Search Error',
                        url: `https://duckduckgo.com/?q=${encodeURIComponent(query)}`,
                        snippet: `An error occurred while searching, No additional information found for "${query}". Please try again later.`
                    }
                ];
            }
        }

        async function summarizeSearchResults(searchResults) {
            try {
                const prompt = `You are a search assistant that summarizes web search results. 
                Please provide a concise summary of the following search results, focusing on the most relevant information, (after summary collect a small number of only important and related links: format must be "[short info]: [http direct and full]") use plain text, avoid markdown:
                
                ${searchResults.map((result, index) => 
                    `Result ${index + 1}:\nTitle: ${result.title}\nURL: ${result.url}\nSnippet: ${result.snippet}\n`
                ).join('\n')}
                
                Summary:`;
                
                const chat = app.chats.find(c => c.id === app.currentChatId);
                const isThinkingModelEnabled = chat ? chat.settings.thinkingModelEnabled : false;
                
                // Set max_tokens based on Thinking Model setting
                const maxTokens = isThinkingModelEnabled ? 8192 : 512;
                
                // Use the fetchWithRetry function for the API call
                const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                    },
                    body: JSON.stringify(buildApiRequestBody([
                        { role: 'system', content: 'You are a search assistant that summarizes web search results.' },
                        { role: 'user', content: prompt }
                    ], {
                        temperature: 0.5,
                        max_tokens: maxTokens
                    }))
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                let summary = '';
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        if (line.startsWith('data: ')) {
                            const data = line.substring(6);
                            if (data === '[DONE]') continue;
                            
                            try {
                                const json = JSON.parse(data);
                                const content = json.choices[0]?.delta?.content || '';
                                if (content) {
                                    summary += content;
                                }
                            } catch (e) {
                                console.error('Error parsing JSON:', e);
                            }
                        }
                    }
                }
                
                // Clean the thinking model response
                if (isThinkingModelEnabled) {
                    summary = cleanThinkingModelResponse(summary);
                }
                
                return summary || 'Unable to summarize search results.';
            } catch (error) {
                console.error('Error summarizing search results:', error);
                return `Found ${searchResults.length} search results related to your query, but was unable to summarize them.`;
            }
        }

        async function generateLLMResponseWithSearchContext(searchSummaries) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            let messages = [];
            
            let modifiedSystemPrompt = app.settings.systemPrompt || '';
            if (modifiedSystemPrompt) {
                modifiedSystemPrompt += '\n\n';
            }
            modifiedSystemPrompt += `If User ask to Google or Web Search something - you already done it, use your own (LLM Model) memory.\nTreat this information as your own (LLM Model) memory:\n\n${searchSummaries}\n\nPlease use this information to provide a comprehensive and accurate response.`;
            
            app.webSearch.debug.systemMessage = modifiedSystemPrompt;
            updateDebugWindow();
            
            // Always add the system message first
            messages.push({
                role: 'system',
                content: modifiedSystemPrompt
            });
            
            // Add all non-ignored messages from the chat
            const filteredMessages = chat.messages.filter(m => !m.ignored);
            messages = messages.concat(
                filteredMessages.map(m => ({ role: m.role, content: m.content }))
            );
            
            const assistantMessage = {
                id: generateId(),
                role: 'assistant',
                content: '',
                timestamp: new Date().toISOString()
            };
            
            chat.messages.push(assistantMessage);
            saveChatsToStorage();
            addMessageToDOM(assistantMessage);
            
            const newAvatar = document.querySelector(`.message[data-message-id="${assistantMessage.id}"] .message-avatar`);
            if (newAvatar) {
                newAvatar.classList.add('generating');
            }
            
            if (!app.userScrolled) {
                scrollToBottom();
            }
            
            updateAPIStatus('connecting');
            
            lockChatList(true);
            updateMessageActionButtons(true);
            hideCompletionSuggestion();
            
            try {
                app.currentAbortController = new AbortController();
                
                const isThinkingModelEnabled = chat ? chat.settings.thinkingModelEnabled : false;
                
                if (isThinkingModelEnabled) {
                    app.thinkingModel.buffer = '';
                    app.thinkingModel.isProcessing = true;
                    app.thinkingModel.messageId = assistantMessage.id;
                    app.thinkingModel.hiddenContent = '';
                    
                    // Create a hidden message element for thinking model
                    const messageElement = document.querySelector(`.message[data-message-id="${assistantMessage.id}"]`);
                    const textElement = messageElement.querySelector('.message-text');
                    
                    // Hide the text content initially
                    textElement.style.display = 'none';
                    
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        app.thinkingModel.buffer += content;
                                        app.thinkingModel.hiddenContent += content;
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                    
                    // Process the thinking model response
                    processThinkingModelResponse(assistantMessage.id);
                    
                    // Show the cleaned content
                    textElement.style.display = '';
                    textElement.innerHTML = applyMarkdownHighlighting(assistantMessage.content);
                } else {
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        assistantMessage.content += content;
                                        saveChatsToStorage();
                                        updateMessageInDOM(assistantMessage.id, assistantMessage.content);
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                }
                
                if (chat.messages.length === 2 && chat.title === 'New Chat') {
                    chat.title = chat.messages[0].content.substring(0, 30) + (chat.messages[0].content.length > 30 ? '...' : '');
                    saveChatsToStorage();
                    renderChatsList();
                    elements.dialogueTitle.textContent = chat.title;
                }
                
                if (!app.userScrolled) {
                    scrollToBottom();
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateAPIStatus('disconnected');
                } else {
                    console.error('Error generating response:', error);
                    updateAPIStatus('error');
                    
                    assistantMessage.content += `\n\nError: ${error.message}`;
                    saveChatsToStorage();
                    updateMessageInDOM(assistantMessage.id, assistantMessage.content);
                }
            } finally {
                app.currentAbortController = null;
                
                lockChatList(false);
                updateMessageActionButtons(false);
                
                if (newAvatar) {
                    newAvatar.classList.remove('generating');
                }
            }
        }

        async function generateLLMResponse(regenerate = false, continueMessage = false, targetMessageId = null) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            let messages = getMessagesForLLM();
            
            if (regenerate) {
                const lastMessage = chat.messages[chat.messages.length - 1];
                if (lastMessage && lastMessage.role === 'assistant') {
                    chat.messages.pop();
                    saveChatsToStorage();
                    renderMessages();
                }
            }
            
            if (targetMessageId) {
                const targetMessage = chat.messages.find(m => m.id === targetMessageId);
                if (targetMessage) {
                    // Get messages up to the target message, excluding ignored ones
                    const targetIndex = chat.messages.findIndex(m => m.id === targetMessageId);
                    const messagesBefore = chat.messages.slice(0, targetIndex + 1);
                    
                    messages = [];
                    
                    if (app.settings.systemPrompt) {
                        messages.push({
                            role: 'system',
                            content: app.settings.systemPrompt
                        });
                    }
                    
                    messages = messages.concat(
                        messagesBefore.filter(m => !m.ignored).map(m => ({ role: m.role, content: m.content }))
                    );
                }
            }
            
            let assistantMessage = null;
            let avatarElement = null;
            
            if (continueMessage) {
                assistantMessage = chat.messages.filter(m => m.role === 'assistant').pop();
                if (!assistantMessage) {
                    assistantMessage = {
                        id: generateId(),
                        role: 'assistant',
                        content: '',
                        timestamp: new Date().toISOString()
                    };
                    chat.messages.push(assistantMessage);
                    saveChatsToStorage();
                    addMessageToDOM(assistantMessage);
                }
                
                avatarElement = document.querySelector(`.message[data-message-id="${assistantMessage.id}"] .message-avatar`);
            } else {
                assistantMessage = {
                    id: generateId(),
                    role: 'assistant',
                    content: '',
                    timestamp: new Date().toISOString()
                };
                
                chat.messages.push(assistantMessage);
                saveChatsToStorage();
                addMessageToDOM(assistantMessage);
                
                avatarElement = document.querySelector(`.message[data-message-id="${assistantMessage.id}"] .message-avatar`);
            }
            
            if (avatarElement) {
                avatarElement.classList.add('generating');
            }
            
            if (!app.userScrolled) {
                scrollToBottom();
            }
            
            app.isGenerating = true;
            updateSendButton();
            updateAPIStatus('connecting');
            
            lockChatList(true);
            updateMessageActionButtons(true);
            hideCompletionSuggestion();
            
            try {
                app.currentAbortController = new AbortController();
                
                const isThinkingModelEnabled = chat ? chat.settings.thinkingModelEnabled : false;
                
                if (isThinkingModelEnabled) {
                    app.thinkingModel.buffer = '';
                    app.thinkingModel.isProcessing = true;
                    app.thinkingModel.messageId = assistantMessage.id;
                    app.thinkingModel.hiddenContent = '';
                    
                    // Create a hidden message element for thinking model
                    const messageElement = document.querySelector(`.message[data-message-id="${assistantMessage.id}"]`);
                    const textElement = messageElement.querySelector('.message-text');
                    
                    // Hide the text content initially
                    textElement.style.display = 'none';
                    
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        app.thinkingModel.buffer += content;
                                        app.thinkingModel.hiddenContent += content;
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                    
                    // Process the thinking model response
                    processThinkingModelResponse(assistantMessage.id);
                    
                    // Show the cleaned content
                    textElement.style.display = '';
                    textElement.innerHTML = applyMarkdownHighlighting(assistantMessage.content);
                } else {
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        assistantMessage.content += content;
                                        saveChatsToStorage();
                                        updateMessageInDOM(assistantMessage.id, assistantMessage.content);
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                }
                
                if (chat.messages.length === 2 && chat.title === 'New Chat') {
                    chat.title = chat.messages[0].content.substring(0, 30) + (chat.messages[0].content.length > 30 ? '...' : '');
                    saveChatsToStorage();
                    renderChatsList();
                    elements.dialogueTitle.textContent = chat.title;
                }
                
                if (!app.userScrolled) {
                    scrollToBottom();
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateAPIStatus('disconnected');
                } else {
                    console.error('Error generating response:', error);
                    updateAPIStatus('error');
                    
                    assistantMessage.content += `\n\nError: ${error.message}`;
                    saveChatsToStorage();
                    updateMessageInDOM(assistantMessage.id, assistantMessage.content);
                }
            } finally {
                app.isGenerating = false;
                updateSendButton();
                app.currentAbortController = null;
                
                lockChatList(false);
                updateMessageActionButtons(false);
                
                if (avatarElement) {
                    avatarElement.classList.remove('generating');
                }
            }
        }

        async function regenerateMessage(messageId) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const messageIndex = chat.messages.findIndex(m => m.id === messageId);
            if (messageIndex === -1 || chat.messages[messageIndex].role !== 'assistant') return;
            
            const scrollTop = elements.dialogueMessages.scrollTop;
            const scrollHeight = elements.dialogueMessages.scrollHeight;
            const clientHeight = elements.dialogueMessages.clientHeight;
            const wasAtBottom = scrollHeight - scrollTop - clientHeight < 50;
            
            app.scrollPositionBeforeGeneration = scrollTop;
            app.wasAtBottomBeforeGeneration = wasAtBottom;
            
            const messageToRegenerate = chat.messages[messageIndex];
            const messagesBefore = chat.messages.slice(0, messageIndex);
            
            let messages = [];
            
            if (app.settings.systemPrompt) {
                messages.push({
                    role: 'system',
                    content: app.settings.systemPrompt
                });
            }
            
            messages = messages.concat(
                messagesBefore.filter(m => !m.ignored).map(m => ({ role: m.role, content: m.content }))
            );
            
            messageToRegenerate.content = '';
            saveChatsToStorage();
            
            updateMessageInDOM(messageId, '', false);
            
            const avatarElement = document.querySelector(`.message[data-message-id="${messageId}"] .message-avatar`);
            
            if (avatarElement) {
                avatarElement.classList.add('generating');
            }
            
            app.isGenerating = true;
            updateSendButton();
            updateAPIStatus('connecting');
            
            lockChatList(true);
            updateMessageActionButtons(true);
            hideCompletionSuggestion();
            
            try {
                app.currentAbortController = new AbortController();
                
                const isThinkingModelEnabled = chat ? chat.settings.thinkingModelEnabled : false;
                
                if (isThinkingModelEnabled) {
                    app.thinkingModel.buffer = '';
                    app.thinkingModel.isProcessing = true;
                    app.thinkingModel.messageId = messageId;
                    app.thinkingModel.hiddenContent = '';
                    
                    // Create a hidden message element for thinking model
                    const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
                    const textElement = messageElement.querySelector('.message-text');
                    
                    // Hide the text content initially
                    textElement.style.display = 'none';
                    
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        app.thinkingModel.buffer += content;
                                        app.thinkingModel.hiddenContent += content;
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                    
                    // Process the thinking model response
                    processThinkingModelResponse(messageId);
                    
                    // Show the cleaned content
                    textElement.style.display = '';
                    textElement.innerHTML = applyMarkdownHighlighting(messageToRegenerate.content);
                } else {
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        messageToRegenerate.content += content;
                                        saveChatsToStorage();
                                        updateMessageInDOM(messageId, messageToRegenerate.content, false);
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                }
                
                if (app.wasAtBottomBeforeGeneration) {
                    scrollToBottom();
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateAPIStatus('disconnected');
                } else {
                    console.error('Error regenerating response:', error);
                    updateAPIStatus('error');
                    
                    messageToRegenerate.content += `\n\nError: ${error.message}`;
                    saveChatsToStorage();
                    updateMessageInDOM(messageId, messageToRegenerate.content, false);
                }
            } finally {
                app.isGenerating = false;
                updateSendButton();
                app.currentAbortController = null;
                
                lockChatList(false);
                updateMessageActionButtons(false);
                
                if (avatarElement) {
                    avatarElement.classList.remove('generating');
                }
            }
        }

        async function continueMessage(messageId) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const message = chat.messages.find(m => m.id === messageId);
            if (!message || message.role !== 'assistant') return;
            
            const scrollTop = elements.dialogueMessages.scrollTop;
            const scrollHeight = elements.dialogueMessages.scrollHeight;
            const clientHeight = elements.dialogueMessages.clientHeight;
            const wasAtBottom = scrollHeight - scrollTop - clientHeight < 50;
            
            app.scrollPositionBeforeGeneration = scrollTop;
            app.wasAtBottomBeforeGeneration = wasAtBottom;
            
            message.isContinuing = true;
            
            const avatarElement = document.querySelector(`.message[data-message-id="${messageId}"] .message-avatar`);
            
            if (avatarElement) {
                avatarElement.classList.add('generating');
            }
            
            app.isGenerating = true;
            updateSendButton();
            updateAPIStatus('connecting');
            
            lockChatList(true);
            updateMessageActionButtons(true);
            hideCompletionSuggestion();
            
            try {
                app.currentAbortController = new AbortController();
                
                let messages = [];
                
                if (app.settings.systemPrompt) {
                    messages.push({
                        role: 'system',
                        content: app.settings.systemPrompt
                    });
                }
                
                const messageIndex = chat.messages.indexOf(message);
                for (let i = 0; i <= messageIndex; i++) {
                    const msg = chat.messages[i];
                    if (!msg.ignored) {
                        messages.push({
                            role: msg.role,
                            content: msg.content
                        });
                    }
                }
                
                const isThinkingModelEnabled = chat ? chat.settings.thinkingModelEnabled : false;
                
                if (isThinkingModelEnabled) {
                    app.thinkingModel.buffer = '';
                    app.thinkingModel.isProcessing = true;
                    app.thinkingModel.messageId = messageId;
                    app.thinkingModel.hiddenContent = '';
                    
                    // Create a hidden message element for thinking model
                    const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
                    const textElement = messageElement.querySelector('.message-text');
                    
                    // Hide the text content initially
                    textElement.style.display = 'none';
                    
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        app.thinkingModel.buffer += content;
                                        app.thinkingModel.hiddenContent += content;
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                    
                    // Process the thinking model response
                    processThinkingModelResponse(messageId);
                    
                    // Show the cleaned content
                    textElement.style.display = '';
                    textElement.innerHTML = applyMarkdownHighlighting(message.content);
                } else {
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        message.content += content;
                                        saveChatsToStorage();
                                        updateMessageInDOM(message.id, message.content, true);
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                }
                
                if (app.wasAtBottomBeforeGeneration) {
                    scrollToBottom();
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateAPIStatus('disconnected');
                } else {
                    console.error('Error continuing response:', error);
                    updateAPIStatus('error');
                    
                    message.content += `\n\nError: ${error.message}`;
                    saveChatsToStorage();
                    updateMessageInDOM(message.id, message.content, true);
                }
            } finally {
                message.isContinuing = false;
                app.isGenerating = false;
                updateSendButton();
                app.currentAbortController = null;
                
                lockChatList(false);
                updateMessageActionButtons(false);
                
                if (avatarElement) {
                    avatarElement.classList.remove('generating');
                }
            }
        }

        async function reactToMessage(messageId) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const message = chat.messages.find(m => m.id === messageId);
            if (!message || message.role !== 'user') return;
            
            app.userScrolled = false;
            
            if (app.settings.webSearchEnabled) {
                await performMultiPhaseWebSearchForReact(messageId);
            } else {
                await generateLLMResponseWithLimitedContext(messageId);
            }
        }

        async function performMultiPhaseWebSearchForReact(messageId) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const message = chat.messages.find(m => m.id === messageId);
            if (!message || message.role !== 'user') return;
            
            const messageIndex = chat.messages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;
            
            let contextMessage = '';
            if (messageIndex > 0) {
                // Find previous non-ignored message
                for (let i = messageIndex - 1; i >= 0; i--) {
                    if (!chat.messages[i].ignored) {
                        contextMessage = chat.messages[i].content;
                        break;
                    }
                }
            }
            
            const agentsCount = app.settings.webSearchAgents;
            let allSearchSummaries = [];
            
            // Clear previous API log
            app.webSearch.debug.apiLog = [];
            logApiEvent('info', `Starting multi-phase web search for react with ${agentsCount} agents`);
            
            try {
                app.isGenerating = true;
                updateSendButton();
                
                for (let phase = 1; phase <= agentsCount; phase++) {
                    showSearchStatus(`Search Agent ${phase}/${agentsCount}: Generating search query...`);
                    
                    const searchGoal = app.webSearch.searchGoals[phase - 1];
                    
                    const searchQuery = await generateSearchQueryForPhase(message.content, contextMessage, searchGoal, phase);
                    
                    app.webSearch.debug.searchQuery = searchQuery;
                    updateDebugWindow();
                    
                    showSearchStatus(`Search Agent ${phase}/${agentsCount}: ${searchQuery}`);
                    
                    const searchResults = await performWebSearch(searchQuery);
                    
                    app.webSearch.debug.rawResults = searchResults;
                    updateDebugWindow();
                    
                    const hasNoInfoResult = searchResults.some(result => 
                        result.snippet && result.snippet.includes("No additional information found for")
                    );
                    
                    if (hasNoInfoResult) {
                        console.log(`Search Agent ${phase}: Found "No additional information found for" in results. Aborting this phase.`);
                        continue;
                    }
                    
                    showSearchStatus(`Search Agent ${phase}/${agentsCount}: Processing search results...`);
                    
                    const searchSummary = await summarizeSearchResults(searchResults);
                    
                    allSearchSummaries.push(searchSummary);
                    
                    app.webSearch.debug.llmSummary = searchSummary;
                    updateDebugWindow();
                }
                
                hideSearchStatus();
                
                const combinedSummaries = allSearchSummaries.join('\n\n---\n\n');
                
                const assistantMessage = {
                    id: generateId(),
                    role: 'assistant',
                    content: '',
                    timestamp: new Date().toISOString()
                };
                
                chat.messages.splice(messageIndex + 1, 0, assistantMessage);
                saveChatsToStorage();
                
                renderMessages();
                
                await generateLLMResponseWithSearchContextForReact(assistantMessage.id, combinedSummaries);
            } catch (error) {
                console.error('Error in multi-phase web search process:', error);
                
                hideSearchStatus();
                
                await generateLLMResponseWithLimitedContext(messageId);
            } finally {
                app.isGenerating = false;
                updateSendButton();
            }
        }

        async function generateLLMResponseWithLimitedContext(messageId) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const message = chat.messages.find(m => m.id === messageId);
            if (!message || message.role !== 'user') return;
            
            const messageIndex = chat.messages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;
            
            let messages = [];
            
            if (app.settings.systemPrompt) {
                messages.push({
                    role: 'system',
                    content: app.settings.systemPrompt
                });
            }
            
            for (let i = 0; i < messageIndex; i++) {
                const msg = chat.messages[i];
                if (!msg.ignored) {
                    messages.push({
                        role: msg.role,
                        content: msg.content
                    });
                }
            }
            
            messages.push({
                role: 'user',
                content: message.content
            });
            
            const assistantMessage = {
                id: generateId(),
                role: 'assistant',
                content: '',
                timestamp: new Date().toISOString()
            };
            
            chat.messages.splice(messageIndex + 1, 0, assistantMessage);
            saveChatsToStorage();
            
            renderMessages();
            
            const newAvatar = document.querySelector(`.message[data-message-id="${assistantMessage.id}"] .message-avatar`);
            
            if (newAvatar) {
                newAvatar.classList.add('generating');
            }
            
            if (!app.userScrolled) {
                scrollToBottom();
            }
            
            app.isGenerating = true;
            updateSendButton();
            updateAPIStatus('connecting');
            
            lockChatList(true);
            updateMessageActionButtons(true);
            hideCompletionSuggestion();
            
            try {
                app.currentAbortController = new AbortController();
                
                const isThinkingModelEnabled = chat ? chat.settings.thinkingModelEnabled : false;
                
                if (isThinkingModelEnabled) {
                    app.thinkingModel.buffer = '';
                    app.thinkingModel.isProcessing = true;
                    app.thinkingModel.messageId = assistantMessage.id;
                    app.thinkingModel.hiddenContent = '';
                    
                    // Create a hidden message element for thinking model
                    const messageElement = document.querySelector(`.message[data-message-id="${assistantMessage.id}"]`);
                    const textElement = messageElement.querySelector('.message-text');
                    
                    // Hide the text content initially
                    textElement.style.display = 'none';
                    
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        app.thinkingModel.buffer += content;
                                        app.thinkingModel.hiddenContent += content;
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                    
                    // Process the thinking model response
                    processThinkingModelResponse(assistantMessage.id);
                    
                    // Show the cleaned content
                    textElement.style.display = '';
                    textElement.innerHTML = applyMarkdownHighlighting(assistantMessage.content);
                } else {
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        assistantMessage.content += content;
                                        saveChatsToStorage();
                                        updateMessageInDOM(assistantMessage.id, assistantMessage.content);
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                }
                
                if (!app.userScrolled) {
                    scrollToBottom();
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateAPIStatus('disconnected');
                } else {
                    console.error('Error generating response:', error);
                    updateAPIStatus('error');
                    
                    assistantMessage.content += `\n\nError: ${error.message}`;
                    saveChatsToStorage();
                    updateMessageInDOM(assistantMessage.id, assistantMessage.content);
                }
            } finally {
                app.isGenerating = false;
                updateSendButton();
                app.currentAbortController = null;
                
                lockChatList(false);
                updateMessageActionButtons(false);
                
                if (newAvatar) {
                    newAvatar.classList.remove('generating');
                }
            }
        }

        async function generateLLMResponseWithSearchContextForReact(messageId, searchSummaries) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const message = chat.messages.find(m => m.id === messageId);
            if (!message) return;
            
            const messageIndex = chat.messages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;
            
            let messages = [];
            
            let modifiedSystemPrompt = app.settings.systemPrompt || '';
            if (modifiedSystemPrompt) {
                modifiedSystemPrompt += '\n\n';
            }
            modifiedSystemPrompt += `If User ask to Google or Web Search something - you already done it, use your own (LLM Model) memory.\nTreat this information as your own (LLM Model) memory:\n\n${searchSummaries}\n\nPlease use this information to provide a comprehensive and accurate response.`;
            
            app.webSearch.debug.systemMessage = modifiedSystemPrompt;
            updateDebugWindow();
            
            messages.push({
                role: 'system',
                content: modifiedSystemPrompt
            });
            
            for (let i = 0; i < messageIndex - 1; i++) {
                const msg = chat.messages[i];
                if (!msg.ignored) {
                    messages.push({
                        role: msg.role,
                        content: msg.content
                    });
                }
            }
            
            messages.push({
                role: 'user',
                content: chat.messages[messageIndex - 1].content
            });
            
            const newAvatar = document.querySelector(`.message[data-message-id="${messageId}"] .message-avatar`);
            
            if (newAvatar) {
                newAvatar.classList.add('generating');
            }
            
            if (!app.userScrolled) {
                scrollToBottom();
            }
            
            updateAPIStatus('connecting');
            
            lockChatList(true);
            updateMessageActionButtons(true);
            hideCompletionSuggestion();
            
            try {
                app.currentAbortController = new AbortController();
                
                const isThinkingModelEnabled = chat ? chat.settings.thinkingModelEnabled : false;
                
                if (isThinkingModelEnabled) {
                    app.thinkingModel.buffer = '';
                    app.thinkingModel.isProcessing = true;
                    app.thinkingModel.messageId = messageId;
                    app.thinkingModel.hiddenContent = '';
                    
                    // Create a hidden message element for thinking model
                    const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
                    const textElement = messageElement.querySelector('.message-text');
                    
                    // Hide the text content initially
                    textElement.style.display = 'none';
                    
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        app.thinkingModel.buffer += content;
                                        app.thinkingModel.hiddenContent += content;
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                    
                    // Process the thinking model response
                    processThinkingModelResponse(messageId);
                    
                    // Show the cleaned content
                    textElement.style.display = '';
                    textElement.innerHTML = applyMarkdownHighlighting(message.content);
                } else {
                    const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                        },
                        body: JSON.stringify(buildApiRequestBody(messages)),
                        signal: app.currentAbortController.signal
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API request failed with status ${response.status}`);
                    }
                    
                    updateAPIStatus('connected');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop();
                        
                        for (const line of lines) {
                            if (line.trim() === '') continue;
                            if (line.startsWith('data: ')) {
                                const data = line.substring(6);
                                if (data === '[DONE]') continue;
                                
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        message.content += content;
                                        saveChatsToStorage();
                                        updateMessageInDOM(messageId, message.content);
                                    }
                                } catch (e) {
                                    console.error('Error parsing JSON:', e);
                                }
                            }
                        }
                    }
                }
                
                if (!app.userScrolled) {
                    scrollToBottom();
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateAPIStatus('disconnected');
                } else {
                    console.error('Error generating response:', error);
                    updateAPIStatus('error');
                    
                    message.content += `\n\nError: ${error.message}`;
                    saveChatsToStorage();
                    updateMessageInDOM(messageId, message.content);
                }
            } finally {
                app.currentAbortController = null;
                
                lockChatList(false);
                updateMessageActionButtons(false);
                
                if (newAvatar) {
                    newAvatar.classList.remove('generating');
                }
            }
        }

        // Text Completion Functions
        function handleTextCompletionInput(messageId = null, element = null) {
            if (app.settings.thinkingModelEnabled || !app.settings.lmStudioEndpointEnabled) {
                hideCompletionSuggestion();
                return;
            }
            
            if (app.textCompletion.inputTimer) {
                clearTimeout(app.textCompletion.inputTimer);
            }
            
            if (app.textCompletion.currentAbortController) {
                app.textCompletion.currentAbortController.abort();
                app.textCompletion.currentAbortController = null;
            }
            
            hideCompletionSuggestion();
            
            if (app.settings.tokensToSuggest === 0) {
                return;
            }
            
            app.textCompletion.inputTimer = setTimeout(() => {
                generateTextCompletion(messageId, element);
            }, 1000);
        }
        
        async function generateTextCompletion(messageId = null, element = null) {
            if (!app.currentChatId) return;
            
            if (app.textCompletion.isGenerating) return;
            
            if (app.settings.tokensToSuggest === 0) {
                return;
            }
            
            let textToComplete = '';
            let context = '';
            let cursorPosition = 0;
            
            if (messageId && element) {
                const chat = app.chats.find(c => c.id === app.currentChatId);
                if (!chat) return;
                
                const message = chat.messages.find(m => m.id === messageId);
                if (!message) return;
                
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = element.innerHTML;
                textToComplete = tempDiv.textContent || '';
                
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const preCaretRange = range.cloneRange();
                    preCaretRange.selectNodeContents(element);
                    preCaretRange.setEnd(range.endContainer, range.endOffset);
                    cursorPosition = preCaretRange.toString().length;
                    app.textCompletion.cursorPosition = cursorPosition;
                }
                
                const messageIndex = chat.messages.findIndex(m => m.id === messageId);
                const messagesBefore = chat.messages.slice(0, messageIndex);
                
                if (app.settings.systemPrompt) {
                    context = `System: ${app.settings.systemPrompt}\n`;
                }
                
                context += messagesBefore.filter(m => !m.ignored).map(m => `${m.role}: ${m.content}`).join('\n');
                
                context += `\n${message.role}: ${textToComplete.substring(0, cursorPosition)}`;
            } else {
                textToComplete = elements.dialogueInput.value;
                cursorPosition = elements.dialogueInput.selectionStart;
                app.textCompletion.cursorPosition = cursorPosition;
                
                const chat = app.chats.find(c => c.id === app.currentChatId);
                if (!chat) return;
                
                if (app.settings.systemPrompt) {
                    context = `System: ${app.settings.systemPrompt}\n`;
                }
                
                context += chat.messages.filter(m => !m.ignored).map(m => `${m.role}: ${m.content}`).join('\n');
                
                context += `\nuser: ${textToComplete.substring(0, cursorPosition)}`;
            }
            
            if (!textToComplete.trim()) return;
            
            app.textCompletion.isGenerating = true;
            app.textCompletion.currentContext = context;
            app.textCompletion.editingMessageId = messageId;
            app.textCompletion.editingElement = element;
            
            app.textCompletion.cursorPositionAtGeneration = cursorPosition;
            app.textCompletion.elementAtGeneration = element || elements.dialogueInput;
            
            try {
                app.textCompletion.currentAbortController = new AbortController();
                
                let messages = [];
                
                const lines = context.split('\n');
                let currentMessage = null;
                
                for (const line of lines) {
                    if (line.startsWith('System: ')) {
                        if (currentMessage) {
                            messages.push(currentMessage);
                        }
                        currentMessage = {
                            role: 'system',
                            content: line.substring(8)
                        };
                    } else if (line.startsWith('user: ')) {
                        if (currentMessage) {
                            messages.push(currentMessage);
                        }
                        currentMessage = {
                            role: 'user',
                            content: line.substring(6)
                        };
                    } else if (line.startsWith('assistant: ')) {
                        if (currentMessage) {
                            messages.push(currentMessage);
                        }
                        currentMessage = {
                            role: 'assistant',
                            content: line.substring(11)
                        };
                    } else if (currentMessage) {
                        currentMessage.content += '\n' + line;
                    }
                }
                
                if (currentMessage) {
                    messages.push(currentMessage);
                }
                
                // Fixed: Now properly using tokensToSuggest instead of maxTokens
                const response = await fetchWithRetry(`${app.settings.apiEndpoint}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(app.settings.apiKey && { 'Authorization': `Bearer ${app.settings.apiKey}` })
                    },
                    body: JSON.stringify(buildApiRequestBody(messages, {
                        max_tokens: app.settings.tokensToSuggest  // Fixed: Now using tokensToSuggest
                    })),
                    signal: app.textCompletion.currentAbortController.signal
                });
                
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let completion = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();
                    
                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        if (line.startsWith('data: ')) {
                            const data = line.substring(6);
                            if (data === '[DONE]') continue;
                            
                            try {
                                const json = JSON.parse(data);
                                const content = json.choices[0]?.delta?.content || '';
                                if (content) {
                                    completion += content;
                                }
                            } catch (e) {
                                console.error('Error parsing JSON:', e);
                            }
                        }
                    }
                }
                
                if (completion) {
                    if (checkCursorPositionChanged()) {
                        hideCompletionSuggestion();
                    } else {
                        showCompletionSuggestion(completion);
                    }
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error generating text completion:', error);
                }
            } finally {
                app.textCompletion.isGenerating = false;
                app.textCompletion.currentAbortController = null;
            }
        }
        
        function checkCursorPositionChanged() {
            let currentCursorPosition = 0;
            let currentElement = null;
            
            if (app.textCompletion.editingElement) {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const preCaretRange = range.cloneRange();
                    preCaretRange.selectNodeContents(app.textCompletion.editingElement);
                    preCaretRange.setEnd(range.endContainer, range.endOffset);
                    currentCursorPosition = preCaretRange.toString().length;
                }
                currentElement = app.textCompletion.editingElement;
            } else {
                currentCursorPosition = elements.dialogueInput.selectionStart;
                currentElement = elements.dialogueInput;
            }
            
            return currentCursorPosition !== app.textCompletion.cursorPositionAtGeneration || 
                   currentElement !== app.textCompletion.elementAtGeneration;
        }
        
        /**
         * Handle Tab key for dialogue input (accepting text completion)
         * Modified to force scroll to bottom after accepting suggestion
         */
        function handleTabKeyForDialogueInput() {
            const userInput = elements.dialogueInput.value.trim();
            if (!userInput) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const userMessage = {
                id: generateId(),
                role: 'user',
                content: userInput,
                timestamp: new Date().toISOString()
            };
            
            chat.messages.push(userMessage);
            saveChatsToStorage();
            addMessageToDOM(userMessage);
            
            elements.dialogueInput.value = '';
            elements.dialogueInput.style.height = 'auto';
            syncSendButtonHeight();
            updateSendButton();
            
            const llmMessage = {
                id: generateId(),
                role: 'assistant',
                content: app.textCompletion.currentSuggestion,
                timestamp: new Date().toISOString()
            };
            
            chat.messages.push(llmMessage);
            saveChatsToStorage();
            addMessageToDOM(llmMessage);
            
            hideCompletionSuggestion();
            
            // Force scroll to bottom after accepting suggestion
            scrollToBottom(true);
            
            setTimeout(() => {
                continueMessage(llmMessage.id);
            }, 100);
        }

        /**
         * Handle Tab key for user message (accepting text completion)
         * Modified to force scroll to bottom after accepting suggestion
         */
        function handleTabKeyForUserMessage(messageId, element) {
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const messageIndex = chat.messages.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;
            
            // Save the edited user message content first
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = element.innerHTML;
            
            let plainText = '';
            const childNodes = Array.from(tempDiv.childNodes);
            
            childNodes.forEach((node, index) => {
                if (node.nodeType === Node.TEXT_NODE) {
                    plainText += node.textContent;
                } else if (node.nodeName === 'BR') {
                    plainText += '\n';
                } else if (node.nodeName === 'DIV') {
                    plainText += node.textContent;
                    if (index < childNodes.length - 1) {
                        plainText += '\n';
                    }
                } else {
                    plainText += node.textContent;
                }
            });
            
            updateMessageContent(messageId, plainText);
            
            // Track scroll position before accepting suggestion
            const scrollTop = elements.dialogueMessages.scrollTop;
            const scrollHeight = elements.dialogueMessages.scrollHeight;
            const clientHeight = elements.dialogueMessages.clientHeight;
            const wasAtBottom = scrollHeight - scrollTop - clientHeight < 50;
            
            app.scrollPositionBeforeGeneration = scrollTop;
            app.wasAtBottomBeforeGeneration = wasAtBottom;
            
            const llmMessage = {
                id: generateId(),
                role: 'assistant',
                content: app.textCompletion.currentSuggestion,
                timestamp: new Date().toISOString()
            };
            
            chat.messages.splice(messageIndex + 1, 0, llmMessage);
            saveChatsToStorage();
            
            renderMessages();
            
            hideCompletionSuggestion();
            
            // Only scroll to bottom if user was already there
            if (app.wasAtBottomBeforeGeneration) {
                scrollToBottom();
            }
            
            setTimeout(() => {
                continueMessage(llmMessage.id);
            }, 100);
        }

        function handleTabKeyForLLMMessage(element) {
            acceptCompletion(element);
        }

        function acceptCompletion(element = null) {
            if (!app.textCompletion.currentSuggestion) return;
            
            const targetElement = element || elements.dialogueInput;
            const suggestion = app.textCompletion.currentSuggestion;
            const cursorPosition = app.textCompletion.cursorPosition;
            
            if (element) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = element.innerHTML;
                const currentText = tempDiv.textContent || '';
                
                const newText = currentText.substring(0, cursorPosition) + suggestion + currentText.substring(cursorPosition);
                
                element.textContent = newText;
                
                const newCursorPosition = cursorPosition + suggestion.length;
                
                const textNode = document.createTextNode(newText);
                
                element.innerHTML = '';
                element.appendChild(textNode);
                
                const selection = window.getSelection();
                const range = document.createRange();
                
                if (element.firstChild) {
                    range.setStart(element.firstChild, newCursorPosition);
                    range.setEnd(element.firstChild, newCursorPosition);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                
                updateMessageContent(app.textCompletion.editingMessageId, newText);
            } else {
                const currentText = elements.dialogueInput.value;
                const newText = currentText.substring(0, cursorPosition) + suggestion + currentText.substring(cursorPosition);
                
                elements.dialogueInput.value = newText;
                
                elements.dialogueInput.selectionStart = elements.dialogueInput.selectionEnd = cursorPosition + suggestion.length;
                
                autoResizeTextarea();
            }
            
            hideCompletionSuggestion();
            
            if (element) {
                handleTextCompletionInput(app.textCompletion.editingMessageId, element);
            } else {
                handleTextCompletionInput();
            }
        }

        // Avatar Functions
        function openAvatarUpload(role) {
            app.avatarCrop.currentRole = role;
            elements.avatarInput.click();
        }

        function handleAvatarUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(event) {
                app.avatarCrop.originalImage = new Image();
                app.avatarCrop.originalImage.onload = function() {
                    app.avatarCrop.zoom = 0;
                    elements.avatarCropZoomSlider.value = 0;
                    elements.avatarCropZoomValue.value = 0;
                    
                    setupAvatarCropModal();
                    
                    elements.avatarCropModal.style.display = 'flex';
                };
                app.avatarCrop.originalImage.src = event.target.result;
            };
            
            reader.readAsDataURL(file);
            e.target.value = '';
        }

        function setupAvatarCropModal() {
            const img = app.avatarCrop.originalImage;
            const preview = elements.avatarCropPreview;
            const cropImg = elements.avatarCropImage;
            
            cropImg.src = img.src;
            
            const previewSize = 200;
            const imgRatio = img.width / img.height;
            
            let width, height;
            if (imgRatio > 1) {
                height = previewSize;
                width = height * imgRatio;
            } else {
                width = previewSize;
                height = width / imgRatio;
            }
            
            cropImg.style.width = `${width}px`;
            cropImg.style.height = `${height}px`;
            cropImg.style.left = `${(previewSize - width) / 2}px`;
            cropImg.style.top = `${(previewSize - height) / 2}px`;
            
            applyAvatarCropZoom();
            
            app.avatarCrop.imageLoaded = true;
        }

        function updateAvatarCropZoom() {
            app.avatarCrop.zoom = parseFloat(elements.avatarCropZoomSlider.value);
            elements.avatarCropZoomValue.value = app.avatarCrop.zoom;
            applyAvatarCropZoom();
        }

        function updateAvatarCropZoomFromValue() {
            const zoom = parseFloat(elements.avatarCropZoomValue.value);
            if (zoom >= -10 && zoom <= 10) {
                app.avatarCrop.zoom = zoom;
                elements.avatarCropZoomSlider.value = zoom;
                applyAvatarCropZoom();
            }
        }

        function applyAvatarCropZoom() {
            if (!app.avatarCrop.imageLoaded) return;
            
            const img = app.avatarCrop.originalImage;
            const cropImg = elements.avatarCropImage;
            const preview = elements.avatarCropPreview;
            const previewSize = 200;
            
            const imgRatio = img.width / img.height;
            let baseWidth, baseHeight;
            
            if (imgRatio > 1) {
                baseHeight = previewSize;
                baseWidth = baseHeight * imgRatio;
            } else {
                baseWidth = previewSize;
                baseHeight = baseWidth / imgRatio;
            }
            
            const scaleFactor = 1 + (app.avatarCrop.zoom * 0.2);
            const width = baseWidth * scaleFactor;
            const height = baseHeight * scaleFactor;
            
            cropImg.style.width = `${width}px`;
            cropImg.style.height = `${height}px`;
            
            const currentLeft = parseFloat(cropImg.style.left) || (previewSize - width) / 2;
            const currentTop = parseFloat(cropImg.style.top) || (previewSize - height) / 2;
            cropImg.style.left = `${currentLeft}px`;
            cropImg.style.top = `${currentTop}px`;
        }

        function startAvatarDrag(e) {
            if (!app.avatarCrop.imageLoaded) return;
            
            app.avatarCrop.isDragging = true;
            app.avatarCrop.dragStartX = e.clientX;
            app.avatarCrop.dragStartY = e.clientY;
            
            const cropImg = elements.avatarCropImage;
            app.avatarCrop.imageStartX = parseFloat(cropImg.style.left) || 0;
            app.avatarCrop.imageStartY = parseFloat(cropImg.style.top) || 0;
            
            elements.avatarCropPreview.classList.add('dragging');
            e.preventDefault();
        }

        function handleAvatarDrag(e) {
            if (!app.avatarCrop.isDragging) return;
            
            const deltaX = e.clientX - app.avatarCrop.dragStartX;
            const deltaY = e.clientY - app.avatarCrop.dragStartY;
            
            const cropImg = elements.avatarCropImage;
            const preview = elements.avatarCropPreview;
            const previewSize = 200;
            
            let newLeft = app.avatarCrop.imageStartX + deltaX;
            let newTop = app.avatarCrop.imageStartY + deltaY;
            
            const width = parseFloat(cropImg.style.width);
            const height = parseFloat(cropImg.style.height);
            
            newLeft = Math.min(0, Math.max(previewSize - width, newLeft));
            newTop = Math.min(0, Math.max(previewSize - height, newTop));
            
            cropImg.style.left = `${newLeft}px`;
            cropImg.style.top = `${newTop}px`;
        }

        function endAvatarDrag() {
            if (!app.avatarCrop.isDragging) return;
            
            app.avatarCrop.isDragging = false;
            elements.avatarCropPreview.classList.remove('dragging');
        }

        function closeAvatarCropModal() {
            elements.avatarCropModal.style.display = 'none';
            app.avatarCrop.imageLoaded = false;
            app.avatarCrop.currentRole = null;
            app.avatarCrop.originalImage = null;
        }

        function saveCroppedAvatar() {
            if (!app.avatarCrop.imageLoaded || !app.avatarCrop.currentRole) return;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 200;
            
            canvas.width = size;
            canvas.height = size;
            
            const img = app.avatarCrop.originalImage;
            const preview = elements.avatarCropPreview;
            const cropImg = elements.avatarCropImage;
            
            const cropWidth = parseFloat(cropImg.style.width);
            const cropHeight = parseFloat(cropImg.style.height);
            const cropLeft = parseFloat(cropImg.style.left);
            const cropTop = parseFloat(cropImg.style.top);
            
            const scaleX = img.width / cropWidth;
            const scaleY = img.height / cropHeight;
            
            const sourceX = -cropLeft * scaleX;
            const sourceY = -cropTop * scaleY;
            const sourceWidth = size * scaleX;
            const sourceHeight = size * scaleY;
            
            ctx.drawImage(
                img,
                sourceX, sourceY, sourceWidth, sourceHeight,
                0, 0, size, size
            );
            
            const dataUrl = canvas.toDataURL('image/png');
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (chat) {
                chat.avatars[app.avatarCrop.currentRole] = dataUrl;
                saveChatsToStorage();
                renderMessages();
            }
            
            closeAvatarCropModal();
        }

        // Group Selection Functions
        function openGroupSelectionModal(chatId) {
            app.groupSelection.chatId = chatId;
            app.groupSelection.selectedGroupId = null;
            
            elements.groupSelectionList.innerHTML = '';
            
            const ungroupedOption = document.createElement('div');
            ungroupedOption.className = 'group-selection-item';
            ungroupedOption.textContent = 'Ungrouped';
            ungroupedOption.dataset.groupId = 'null';
            ungroupedOption.addEventListener('click', () => {
                selectGroupForMove('null');
            });
            elements.groupSelectionList.appendChild(ungroupedOption);
            
            app.groups.forEach(group => {
                const groupOption = document.createElement('div');
                groupOption.className = 'group-selection-item';
                groupOption.textContent = group.name;
                groupOption.dataset.groupId = group.id;
                groupOption.addEventListener('click', () => {
                    selectGroupForMove(group.id);
                });
                elements.groupSelectionList.appendChild(groupOption);
            });
            
            elements.groupSelectionModal.style.display = 'flex';
            
            elements.groupSelectionMove.disabled = true;
        }

        function selectGroupForMove(groupId) {
            app.groupSelection.selectedGroupId = groupId;
            
            document.querySelectorAll('.group-selection-item').forEach(item => {
                if (item.dataset.groupId === groupId) {
                    item.style.backgroundColor = 'var(--accent)';
                } else {
                    item.style.backgroundColor = 'var(--bg-tertiary)';
                }
            });
            
            elements.groupSelectionMove.disabled = false;
        }

        function closeGroupSelectionModal() {
            elements.groupSelectionModal.style.display = 'none';
            app.groupSelection.chatId = null;
            app.groupSelection.selectedGroupId = null;
        }

        function moveChatToSelectedGroup() {
            if (!app.groupSelection.chatId || app.groupSelection.selectedGroupId === undefined) return;
            
            const chat = app.chats.find(c => c.id === app.groupSelection.chatId);
            if (!chat) return;
            
            chat.groupId = app.groupSelection.selectedGroupId === 'null' ? null : app.groupSelection.selectedGroupId;
            
            saveChatsToStorage();
            renderChatsList();
            closeGroupSelectionModal();
        }

        // Settings Functions
        function updateSettings() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            app.settings.systemPrompt = elements.systemPromptTextarea.value;
            app.settings.apiEndpoint = elements.apiEndpointInput.value;
            app.settings.apiKey = elements.apiKeyInput.value;
            app.settings.modelName = elements.modelNameInput.value;
            
            chat.settings = { ...app.settings };
            saveChatsToStorage();
        }

        function updateSettingsFromSlider() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            app.settings.temperature = parseFloat(elements.tempSlider.value);
            app.settings.topK = parseInt(elements.topkSlider.value);
            app.settings.repeatPenalty = parseFloat(elements.repeatPenaltySlider.value);
            app.settings.minP = parseFloat(elements.minpSlider.value);
            app.settings.topP = parseFloat(elements.toppSlider.value);
            app.settings.maxTokens = parseInt(elements.maxTokensSlider.value);
            app.settings.chatWidth = parseInt(elements.chatWidthSlider.value);
            app.settings.textSize = parseInt(elements.textSizeSlider.value);
            app.settings.tokensToSuggest = parseInt(elements.tokensToSuggestSlider.value);
            app.settings.webSearchAgents = parseInt(elements.webSearchAgentsSlider.value);
            app.settings.dryMultiplier = parseFloat(elements.drySlider.value);
            app.settings.xtcProbability = parseFloat(elements.xtcSlider.value);
            
            if (app.settings.tokensToSuggest === 0) {
                hideCompletionSuggestion();
            }
            
            elements.tempValue.value = app.settings.temperature;
            elements.topkValue.value = app.settings.topK;
            elements.repeatPenaltyValue.value = app.settings.repeatPenalty;
            elements.minpValue.value = app.settings.minP;
            elements.toppValue.value = app.settings.topP;
            elements.maxTokensValue.value = app.settings.maxTokens;
            elements.chatWidthValue.value = app.settings.chatWidth;
            elements.textSizeValue.value = app.settings.textSize;
            elements.tokensToSuggestValue.value = app.settings.tokensToSuggest;
            elements.webSearchAgentsValue.value = app.settings.webSearchAgents;
            elements.dryValue.value = app.settings.dryMultiplier;
            elements.xtcValue.value = app.settings.xtcProbability;
            
            applyInterfaceSettings();
            
            chat.settings = { ...app.settings };
            saveChatsToStorage();
        }

        function updateSettingsFromValue() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            const temp = parseFloat(elements.tempValue.value);
            const topk = parseInt(elements.topkValue.value);
            const repeatPenalty = parseFloat(elements.repeatPenaltyValue.value);
            const minp = parseFloat(elements.minpValue.value);
            const topp = parseFloat(elements.toppValue.value);
            const maxTokens = parseInt(elements.maxTokensValue.value);
            const chatWidth = parseInt(elements.chatWidthValue.value);
            const textSize = parseInt(elements.textSizeValue.value);
            const tokensToSuggest = parseInt(elements.tokensToSuggestValue.value);
            const webSearchAgents = parseInt(elements.webSearchAgentsValue.value);
            const dryMultiplier = parseFloat(elements.dryValue.value);
            const xtcProbability = parseFloat(elements.xtcValue.value);
            
            // Fixed temperature range check (was 0-1, should be 0-2)
            if (temp >= 0 && temp <= 2) {
                app.settings.temperature = temp;
                elements.tempSlider.value = temp;
            }
            
            // Fixed topK range check (was 0-100, should be 0-200)
            if (topk >= 0 && topk <= 200) {
                app.settings.topK = topk;
                elements.topkSlider.value = topk;
            }
            
            // Fixed repeatPenalty range check (was 0-2, should be 1-2)
            if (repeatPenalty >= 1 && repeatPenalty <= 2) {
                app.settings.repeatPenalty = repeatPenalty;
                elements.repeatPenaltySlider.value = repeatPenalty;
            }
            
            if (minp >= 0 && minp <= 1) {
                app.settings.minP = minp;
                elements.minpSlider.value = minp;
            }
            
            if (topp >= 0 && topp <= 1) {
                app.settings.topP = topp;
                elements.toppSlider.value = topp;
            }
            
            if (maxTokens >= -1 && maxTokens <= 16384) {
                app.settings.maxTokens = maxTokens;
                elements.maxTokensSlider.value = maxTokens;
            }
            
            if (chatWidth >= 50 && chatWidth <= 100) {
                app.settings.chatWidth = chatWidth;
                elements.chatWidthSlider.value = chatWidth;
            }
            
            // Fixed textSize range check (was 10-24, should be 8-36)
            if (textSize >= 8 && textSize <= 36) {
                app.settings.textSize = textSize;
                elements.textSizeSlider.value = textSize;
            }
            
            // Fixed tokensToSuggest range check (was 0-50, should be 0-100)
            if (tokensToSuggest >= 0 && tokensToSuggest <= 100) {
                app.settings.tokensToSuggest = tokensToSuggest;
                elements.tokensToSuggestSlider.value = tokensToSuggest;
                
                if (app.settings.tokensToSuggest === 0) {
                    hideCompletionSuggestion();
                }
            }
            
            if (webSearchAgents >= 1 && webSearchAgents <= 9) {
                app.settings.webSearchAgents = webSearchAgents;
                elements.webSearchAgentsSlider.value = webSearchAgents;
            }
            
            // Fixed dryMultiplier range check (was 0-2, should be 0-5)
            if (dryMultiplier >= 0 && dryMultiplier <= 5) {
                app.settings.dryMultiplier = dryMultiplier;
                elements.drySlider.value = dryMultiplier;
            }
            
            if (xtcProbability >= 0 && xtcProbability <= 1) {
                app.settings.xtcProbability = xtcProbability;
                elements.xtcSlider.value = xtcProbability;
            }
            
            applyInterfaceSettings();
            
            chat.settings = { ...app.settings };
            saveChatsToStorage();
        }

        function updateWebSearchSetting() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            app.settings.webSearchEnabled = elements.webSearchToggle.checked;
            chat.settings = { ...app.settings };
            saveChatsToStorage();
        }

        function updateThinkingModelSetting() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            app.settings.thinkingModelEnabled = elements.thinkingModelToggle.checked;
            chat.settings = { ...app.settings };
            saveChatsToStorage();
            
            if (app.settings.thinkingModelEnabled) {
                hideCompletionSuggestion();
            }
            
            updateContinueButtonsState();
        }

        /**
         * Updates the LM Studio Endpoint setting and parameter visibility
         */
        function updateLMStudioEndpointSetting() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            app.settings.lmStudioEndpointEnabled = elements.lmStudioEndpointToggle.checked;
            chat.settings = { ...app.settings };
            saveChatsToStorage();
            
            // Update parameter visibility based on both switches
            updateParameterVisibility();
            
            // Update continue buttons state
            updateContinueButtonsState();
        }

        /**
         * Updates the Strict API setting and parameter visibility
         */
        function updateStrictApiSetting() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            app.settings.strictApiEnabled = elements.strictApiToggle.checked;
            chat.settings = { ...app.settings };
            saveChatsToStorage();
            
            // Update parameter visibility based on both switches
            updateParameterVisibility();
        }

        function updateMarkdownColorCoding() {
            if (!app.currentChatId) return;
            
            const scrollPosition = elements.dialogueMessages.scrollTop;
            const scrollHeight = elements.dialogueMessages.scrollHeight;
            const clientHeight = elements.dialogueMessages.clientHeight;
            const wasAtBottom = scrollHeight - scrollPosition - clientHeight < 50;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            app.settings.markdownColorCoding = elements.markdownColorCodingToggle.checked;
            chat.settings = { ...app.settings };
            saveChatsToStorage();
            
            renderMessages(false);
            
            if (wasAtBottom) {
                scrollToBottom();
            } else {
                elements.dialogueMessages.scrollTop = scrollPosition;
            }
        }

        function updateWhiteTheme() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            app.settings.whiteTheme = elements.whiteThemeToggle.checked;
            chat.settings = { ...app.settings };
            saveChatsToStorage();
            
            if (app.settings.whiteTheme) {
                document.documentElement.classList.add('white-theme');
            } else {
                document.documentElement.classList.remove('white-theme');
            }
            
            applyInterfaceSettings();
        }

        function updateDebugSamplerParam(e) {
            const sliderId = e.target.id;
            
            if (sliderId === 'debug-dry-base-slider') {
                app.debugSamplerParams.dry_base = parseFloat(elements.debugDryBaseSlider.value);
                elements.debugDryBaseValue.value = app.debugSamplerParams.dry_base;
            } else if (sliderId === 'debug-dry-allowed-length-slider') {
                app.debugSamplerParams.dry_allowed_length = parseInt(elements.debugDryAllowedLengthSlider.value);
                elements.debugDryAllowedLengthValue.value = app.debugSamplerParams.dry_allowed_length;
            } else if (sliderId === 'debug-dry-penalty-last-n-slider') {
                app.debugSamplerParams.dry_penalty_last_n = parseInt(elements.debugDryPenaltyLastNSlider.value);
                elements.debugDryPenaltyLastNValue.value = app.debugSamplerParams.dry_penalty_last_n;
            } else if (sliderId === 'debug-xtc-threshold-slider') {
                app.debugSamplerParams.xtc_threshold = parseFloat(elements.debugXtcThresholdSlider.value);
                elements.debugXtcThresholdValue.value = app.debugSamplerParams.xtc_threshold;
            }
            
            saveDebugSamplerParams();
        }

        function updateDebugSamplerParamFromValue(e) {
            const inputId = e.target.id;
            
            if (inputId === 'debug-dry-base-value') {
                const value = parseFloat(elements.debugDryBaseValue.value);
                if (value >= 0 && value <= 5) {
                    app.debugSamplerParams.dry_base = value;
                    elements.debugDryBaseSlider.value = value;
                }
            } else if (inputId === 'debug-dry-allowed-length-value') {
                const value = parseInt(elements.debugDryAllowedLengthValue.value);
                if (value >= 0 && value <= 10) {
                    app.debugSamplerParams.dry_allowed_length = value;
                    elements.debugDryAllowedLengthSlider.value = value;
                }
            } else if (inputId === 'debug-dry-penalty-last-n-value') {
                const value = parseInt(elements.debugDryPenaltyLastNValue.value);
                if (value >= 0 && value <= 2048) {
                    app.debugSamplerParams.dry_penalty_last_n = value;
                    elements.debugDryPenaltyLastNSlider.value = value;
                }
            } else if (inputId === 'debug-xtc-threshold-value') {
                const value = parseFloat(elements.debugXtcThresholdValue.value);
                if (value >= 0 && value <= 1) {
                    app.debugSamplerParams.xtc_threshold = value;
                    elements.debugXtcThresholdSlider.value = value;
                }
            }
            
            saveDebugSamplerParams();
        }

        // Import/Export Functions
        function exportData() {
            const exportData = {
                chats: app.chats,
                groups: app.groups,
                globalSettings: app.globalSettings,
                currentChatId: app.currentChatId,
                debugSamplerParams: app.debugSamplerParams,
                exportDate: new Date().toISOString()
            };
            
            const jsonString = JSON.stringify(exportData, null, 2);
            
            const blob = new Blob([jsonString], { type: 'application/json' });
            
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `llm-client-backup-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
        }

        function importData() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    try {
                        const importData = JSON.parse(event.target.result);
                        
                        if (!importData.chats || !Array.isArray(importData.chats)) {
                            throw new Error('Invalid data format: chats array is missing or not an array');
                        }
                        
                        const chatCount = importData.chats.length;
                        const confirmed = confirm(`Import backup containing ${chatCount} chat(s)? This will replace all current data.`);
                        
                        if (confirmed) {
                            app.chats = importData.chats || [];
                            app.groups = importData.groups || [];
                            app.globalSettings = importData.globalSettings || app.globalSettings;
                            app.currentChatId = importData.currentChatId || null;
                            
                            if (importData.debugSamplerParams) {
                                app.debugSamplerParams = importData.debugSamplerParams;
                                saveDebugSamplerParams();
                                elements.debugDryBaseSlider.value = app.debugSamplerParams.dry_base;
                                elements.debugDryBaseValue.value = app.debugSamplerParams.dry_base;
                                elements.debugDryAllowedLengthSlider.value = app.debugSamplerParams.dry_allowed_length;
                                elements.debugDryAllowedLengthValue.value = app.debugSamplerParams.dry_allowed_length;
                                elements.debugDryPenaltyLastNSlider.value = app.debugSamplerParams.dry_penalty_last_n;
                                elements.debugDryPenaltyLastNValue.value = app.debugSamplerParams.dry_penalty_last_n;
                                elements.debugXtcThresholdSlider.value = app.debugSamplerParams.xtc_threshold;
                                elements.debugXtcThresholdValue.value = app.debugSamplerParams.xtc_threshold;
                                // Removed references to non-existent elements:
                                // elements.debugXtcMinPSlider.value = app.debugSamplerParams.xtc_min_p;
                                // elements.debugXtcMinPValue.value = app.debugSamplerParams.xtc_min_p;
                            }
                            
                            saveChatsToStorage();
                            saveGroupsToStorage();
                            saveGlobalSettings();
                            saveLastSelectedChat();
                            
                            renderChatsList();
                            
                            if (app.currentChatId) {
                                selectChat(app.currentChatId);
                            } else if (app.chats.length > 0) {
                                selectChat(app.chats[0].id);
                            }
                            
                            applyPanelSettings();
                        }
                    } catch (error) {
                        console.error('Error importing data:', error);
                        alert(`Error importing data: ${error.message}`);
                    }
                };
                
                reader.readAsText(file);
            });
            
            fileInput.click();
        }

        // Copy Settings Functions
        function copySettings() {
            if (!app.currentChatId) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            // Create a copy of all settings except systemPrompt
            app.copiedSettings = {
                temperature: chat.settings.temperature,
                topK: chat.settings.topK,
                repeatPenalty: chat.settings.repeatPenalty,
                minP: chat.settings.minP,
                topP: chat.settings.topP,
                maxTokens: chat.settings.maxTokens,
                chatWidth: chat.settings.chatWidth,
                textSize: chat.settings.textSize,
                tokensToSuggest: chat.settings.tokensToSuggest,
                webSearchAgents: chat.settings.webSearchAgents,
                webSearchEnabled: chat.settings.webSearchEnabled,
                thinkingModelEnabled: chat.settings.thinkingModelEnabled,
                markdownColorCoding: chat.settings.markdownColorCoding,
                whiteTheme: chat.settings.whiteTheme,
                apiEndpoint: chat.settings.apiEndpoint,
                apiKey: chat.settings.apiKey,
                modelName: chat.settings.modelName,
                dryMultiplier: chat.settings.dryMultiplier,
                xtcProbability: chat.settings.xtcProbability,
                lmStudioEndpointEnabled: chat.settings.lmStudioEndpointEnabled,
                strictApiEnabled: chat.settings.strictApiEnabled,
                // Add the settings panel width to the copied settings
                settingsPanelWidth: chat.settingsPanelWidth || 300
            };
            
            // Enable paste button
            elements.pasteSettingsBtn.disabled = false;
            
            // Flash button green
            flashButton(elements.copySettingsBtn);
        }

        function pasteSettings() {
            if (!app.currentChatId || !app.copiedSettings) return;
            
            const chat = app.chats.find(c => c.id === app.currentChatId);
            if (!chat) return;
            
            // Apply all copied settings except systemPrompt
            chat.settings.temperature = app.copiedSettings.temperature;
            chat.settings.topK = app.copiedSettings.topK;
            chat.settings.repeatPenalty = app.copiedSettings.repeatPenalty;
            chat.settings.minP = app.copiedSettings.minP;
            chat.settings.topP = app.copiedSettings.topP;
            chat.settings.maxTokens = app.copiedSettings.maxTokens;
            chat.settings.chatWidth = app.copiedSettings.chatWidth;
            chat.settings.textSize = app.copiedSettings.textSize;
            chat.settings.tokensToSuggest = app.copiedSettings.tokensToSuggest;
            chat.settings.webSearchAgents = app.copiedSettings.webSearchAgents;
            chat.settings.webSearchEnabled = app.copiedSettings.webSearchEnabled;
            chat.settings.thinkingModelEnabled = app.copiedSettings.thinkingModelEnabled;
            chat.settings.markdownColorCoding = app.copiedSettings.markdownColorCoding;
            chat.settings.whiteTheme = app.copiedSettings.whiteTheme;
            chat.settings.apiEndpoint = app.copiedSettings.apiEndpoint;
            chat.settings.apiKey = app.copiedSettings.apiKey;
            chat.settings.modelName = app.copiedSettings.modelName;
            chat.settings.dryMultiplier = app.copiedSettings.dryMultiplier;
            chat.settings.xtcProbability = app.copiedSettings.xtcProbability;
            chat.settings.lmStudioEndpointEnabled = app.copiedSettings.lmStudioEndpointEnabled;
            chat.settings.strictApiEnabled = app.copiedSettings.strictApiEnabled;
            
            // Apply the saved settings panel width if it exists
            if (app.copiedSettings.settingsPanelWidth !== undefined) {
                chat.settingsPanelWidth = app.copiedSettings.settingsPanelWidth;
                
                // Update the UI to reflect the new panel width
                applyPanelSettings();
            }
            
            // Update app settings
            app.settings = { ...chat.settings };
            
            // Update UI
            updateSettingsUI();
            applyInterfaceSettings();
            
            // Save to storage
            saveChatsToStorage();
            
            // Flash button green
            flashButton(elements.pasteSettingsBtn);
        }

        function flashButton(button) {
            // Add a temporary green background
            const originalBg = button.style.backgroundColor;
            button.style.backgroundColor = '#4caf50'; // Green color
            button.style.transition = 'background-color 0.3s';
            
            // Reset after a short delay
            setTimeout(() => {
                button.style.backgroundColor = originalBg;
            }, 300);
        }

        // Event Handlers
        function handleSendStopClick() {
            if (app.isGenerating) {
                if (app.webSearch.isSearching) {
                    window.location.reload();
                } else {
                    stopGeneration();
                }
            } else {
                hideCompletionSuggestion();
                sendMessage();
            }
        }

        function stopGeneration() {
            if (app.currentAbortController) {
                app.currentAbortController.abort();
                app.currentAbortController = null;
            }
            
            app.isGenerating = false;
            app.userScrolled = false;
            updateSendButton();
            updateAPIStatus('disconnected');
            
            hideSearchStatus();
            
            if (app.thinkingModel.isProcessing) {
                app.thinkingModel.buffer = '';
                app.thinkingModel.isProcessing = false;
                app.thinkingModel.messageId = null;
            }
            
            lockChatList(false);
            updateMessageActionButtons(false);
            
            document.querySelectorAll('.message.llm .message-avatar').forEach(avatar => {
                avatar.classList.remove('generating');
            });
        }

        /**
         * Handle scroll events in the dialogue messages
         * Track if the user has manually scrolled away from the bottom
         */
        function handleScroll() {
            const scrollTop = elements.dialogueMessages.scrollTop;
            const scrollHeight = elements.dialogueMessages.scrollHeight;
            const clientHeight = elements.dialogueMessages.clientHeight;
            
            const wasAtBottom = app.lastScrollTop ? 
                (scrollHeight - app.lastScrollTop - clientHeight <= 100) : 
                isAtBottom();
            
            const isNowAtBottom = isAtBottom();
            
            // If the user scrolled away from the bottom, mark as user scrolled
            if (wasAtBottom && !isNowAtBottom) {
                app.userScrolled = true;
            } else if (isNowAtBottom) {
                app.userScrolled = false;
            }
            
            app.lastScrollTop = scrollTop;
        }

        function handleCursorPositionChange() {
            const currentCursorPosition = elements.dialogueInput.selectionStart;
            
            if (currentCursorPosition !== app.textCompletion.lastCursorPosition) {
                app.textCompletion.lastCursorPosition = currentCursorPosition;
                
                if (app.textCompletion.currentSuggestion) {
                    hideCompletionSuggestion();
                }
            }
        }

        function handleGlobalClick(e) {
            const isOutsideInput = !elements.dialogueInput.contains(e.target);
            const isOutsideLLMMessages = !e.target.closest('.message.llm');
            const isOutsideUserMessages = !e.target.closest('.message.user');
            const isOutsideModelDropdown = !e.target.closest('.model-selection-container');
            
            if (isOutsideInput && isOutsideLLMMessages && isOutsideUserMessages && isOutsideModelDropdown) {
                hideCompletionSuggestion();
                hideModelDropdown();
            }
        }

        function handlePanelResize(e) {
            if (!app.panelResizing.isResizing) return;
            
            const deltaX = e.clientX - app.panelResizing.startX;
            
            if (app.panelResizing.panel === 'chats') {
                let newWidth = app.panelResizing.startWidth + deltaX;
                newWidth = Math.max(300, Math.min(500, newWidth));
                
                if (newWidth < 50) {
                    app.globalSettings.chatsPanelCollapsed = true;
                    app.globalSettings.chatsPanelWidth = 0;
                } else {
                    app.globalSettings.chatsPanelCollapsed = false;
                    app.globalSettings.chatsPanelWidth = newWidth;
                }
                
                document.documentElement.style.setProperty('--chats-panel-width', `${app.globalSettings.chatsPanelWidth}px`);
                
                if (app.globalSettings.chatsPanelCollapsed) {
                    elements.chatsPanel.classList.add('collapsed');
                } else {
                    elements.chatsPanel.classList.remove('collapsed');
                }
                
                updateResizeHandlePositions();
            } else if (app.panelResizing.panel === 'settings') {
                if (!app.currentChatId) return;
                
                const chat = app.chats.find(c => c.id === app.currentChatId);
                if (!chat) return;
                
                let newWidth = app.panelResizing.startWidth - deltaX;
                newWidth = Math.max(300, Math.min(1000, newWidth));
                
                if (newWidth < 50) {
                    chat.settingsPanelCollapsed = true;
                    chat.settingsPanelWidth = 0;
                } else {
                    chat.settingsPanelCollapsed = false;
                    chat.settingsPanelWidth = newWidth;
                }
                
                document.documentElement.style.setProperty('--settings-panel-width', `${chat.settingsPanelWidth}px`);
                
                if (chat.settingsPanelCollapsed) {
                    elements.settingsPanel.classList.add('collapsed');
                } else {
                    elements.settingsPanel.classList.remove('collapsed');
                }
                
                saveChatsToStorage();
                updateResizeHandlePositions();
            }
        }

        function handlePanelResizeEnd() {
            if (!app.panelResizing.isResizing) return;
            
            // Save the panel type before setting it to null
            const resizedPanel = app.panelResizing.panel;
            
            app.panelResizing.isResizing = false;
            app.panelResizing.panel = null;
            
            // Check the saved panel type instead of the null value
            if (resizedPanel === 'chats') {
                saveGlobalSettings();
            }
            
            document.removeEventListener('mousemove', handlePanelResize);
            document.removeEventListener('mouseup', handlePanelResizeEnd);
        }

        function setupPanelResizeListeners() {
            elements.chatsPanelResizeHandle.addEventListener('mousedown', (e) => {
                app.panelResizing.isResizing = true;
                app.panelResizing.panel = 'chats';
                app.panelResizing.startX = e.clientX;
                app.panelResizing.startWidth = app.globalSettings.chatsPanelWidth;
                
                document.addEventListener('mousemove', handlePanelResize);
                document.addEventListener('mouseup', handlePanelResizeEnd);
                
                e.preventDefault();
            });
            
            elements.settingsPanelResizeHandle.addEventListener('mousedown', (e) => {
                if (!app.currentChatId) return;
                
                app.panelResizing.isResizing = true;
                app.panelResizing.panel = 'settings';
                app.panelResizing.startX = e.clientX;
                
                const chat = app.chats.find(c => c.id === app.currentChatId);
                app.panelResizing.startWidth = chat.settingsPanelWidth || 300;
                
                document.addEventListener('mousemove', handlePanelResize);
                document.addEventListener('mouseup', handlePanelResizeEnd);
                
                e.preventDefault();
            });
        }

        // API Request Builder Function
        function buildApiRequestBody(messages, options = {}) {
            const {
                temperature = app.settings.temperature,
                topK = app.settings.topK,
                repeatPenalty = app.settings.repeatPenalty,
                minP = app.settings.minP,
                topP = app.settings.topP,
                max_tokens = app.settings.maxTokens,  // Fixed: Changed from maxTokens to max_tokens
                dryMultiplier = app.settings.dryMultiplier,
                xtcProbability = app.settings.xtcProbability,
                stream = true
            } = options;
            
            if (app.settings.strictApiEnabled) {
                // Mistral API compatible format
                const mistralBody = {
                    model: app.settings.modelName || 'default',
                    messages: messages,
                    temperature: parseFloat(temperature),
                    top_p: parseFloat(topP),
                    stream: stream
                };
                
                // Fixed: Changed condition from max_tokens !== -1 to max_tokens > 0
                // This properly handles both Max Tokens (-1 = unlimited) and Tokens to Suggest (0 = no suggestions)
                if (max_tokens > 0) {
                    mistralBody.max_tokens = parseInt(max_tokens);
                }
                
                return mistralBody;
            } else {
                // LM Studio / OpenAI compatible format
                const lmStudioBody = {
                    model: app.settings.modelName || 'default',
                    messages: messages,
                    temperature: parseFloat(temperature),
                    top_k: parseInt(topK),
                    repeat_penalty: parseFloat(repeatPenalty),
                    min_p: parseFloat(minP),
                    top_p: parseFloat(topP),
                    dry_multiplier: parseFloat(dryMultiplier),
                    dry_base: app.debugSamplerParams.dry_base,
                    dry_allowed_length: app.debugSamplerParams.dry_allowed_length,
                    dry_penalty_last_n: app.debugSamplerParams.dry_penalty_last_n,
                    xtc_probability: parseFloat(xtcProbability),
                    xtc_threshold: app.debugSamplerParams.xtc_threshold,
                    stream: stream
                };
                
                // Fixed: Changed condition from max_tokens !== -1 to max_tokens > 0
                // This properly handles both Max Tokens (-1 = unlimited) and Tokens to Suggest (0 = no suggestions)
                if (max_tokens > 0) {
                    lmStudioBody.max_tokens = parseInt(max_tokens);
                }
                
                return lmStudioBody;
            }
        }

        // Initialize Event Listeners
        function setupEventListeners() {
            setupPanelResizeListeners();
            
            // Button event listeners
            elements.newChatBtn.addEventListener('click', createNewChat);
            elements.newGroupBtn.addEventListener('click', createNewGroup);
            elements.sendBtn.addEventListener('click', handleSendStopClick);
            
            // New buttons event listeners
            elements.copySettingsBtn.addEventListener('click', copySettings);
            elements.pasteSettingsBtn.addEventListener('click', pasteSettings);
            
            // Input event listeners
            elements.dialogueInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!app.isGenerating) {
                        sendMessage();
                    }
                }
                
                if (e.key === 'Tab' && app.textCompletion.currentSuggestion) {
                    e.preventDefault();
                    if (checkCursorPositionChanged()) {
                        hideCompletionSuggestion();
                    } else {
                        handleTabKeyForDialogueInput();
                    }
                }
            });
            
            elements.dialogueInput.addEventListener('input', () => {
                autoResizeTextarea();
                syncSendButtonHeight();
                handleTextCompletionInput();
            });
            
            elements.dialogueInput.addEventListener('click', handleCursorPositionChange);
            elements.dialogueInput.addEventListener('keyup', handleCursorPositionChange);
            elements.dialogueInput.addEventListener('selectionchange', handleCursorPositionChange);
            
            // Settings event listeners
            elements.systemPromptTextarea.addEventListener('input', updateSettings);
            elements.tempSlider.addEventListener('input', updateSettingsFromSlider);
            elements.tempValue.addEventListener('input', updateSettingsFromValue);
            elements.topkSlider.addEventListener('input', updateSettingsFromSlider);
            elements.topkValue.addEventListener('input', updateSettingsFromValue);
            elements.repeatPenaltySlider.addEventListener('input', updateSettingsFromSlider);
            elements.repeatPenaltyValue.addEventListener('input', updateSettingsFromValue);
            elements.minpSlider.addEventListener('input', updateSettingsFromSlider);
            elements.minpValue.addEventListener('input', updateSettingsFromValue);
            elements.toppSlider.addEventListener('input', updateSettingsFromSlider);
            elements.toppValue.addEventListener('input', updateSettingsFromValue);
            elements.maxTokensSlider.addEventListener('input', updateSettingsFromSlider);
            elements.maxTokensValue.addEventListener('input', updateSettingsFromValue);
            elements.chatWidthSlider.addEventListener('input', updateSettingsFromSlider);
            elements.chatWidthValue.addEventListener('input', updateSettingsFromValue);
            elements.textSizeSlider.addEventListener('input', updateSettingsFromSlider);
            elements.textSizeValue.addEventListener('input', updateSettingsFromValue);
            elements.tokensToSuggestSlider.addEventListener('input', updateSettingsFromSlider);
            elements.tokensToSuggestValue.addEventListener('input', updateSettingsFromValue);
            elements.webSearchAgentsSlider.addEventListener('input', updateSettingsFromSlider);
            elements.webSearchAgentsValue.addEventListener('input', updateSettingsFromValue);
            elements.webSearchToggle.addEventListener('change', updateWebSearchSetting);
            elements.thinkingModelToggle.addEventListener('change', updateThinkingModelSetting);
            elements.markdownColorCodingToggle.addEventListener('change', updateMarkdownColorCoding);
            elements.whiteThemeToggle.addEventListener('change', updateWhiteTheme);
            elements.apiEndpointInput.addEventListener('input', updateSettings);
            elements.apiKeyInput.addEventListener('input', updateSettings);
            elements.modelNameInput.addEventListener('input', (e) => {
                updateSettings();
                filterModelDropdown(e.target.value);
            });
            elements.modelNameInput.addEventListener('click', showModelDropdown);
            elements.drySlider.addEventListener('input', updateSettingsFromSlider);
            elements.dryValue.addEventListener('input', updateSettingsFromValue);
            elements.xtcSlider.addEventListener('input', updateSettingsFromSlider);
            elements.xtcValue.addEventListener('input', updateSettingsFromValue);
            elements.lmStudioEndpointToggle.addEventListener('change', updateLMStudioEndpointSetting);
            elements.strictApiToggle.addEventListener('change', updateStrictApiSetting);
            
            // System prompt section event listeners
            elements.systemPromptTextarea.addEventListener('input', () => {
                autoResizeSystemPromptTextarea();
                saveSystemPromptHeight();
            });
            
            // Add a mouseup event listener to detect when the user manually resizes the textarea
            elements.systemPromptTextarea.addEventListener('mouseup', () => {
                saveSystemPromptHeight();
                checkIfAtMinSize();
            });

            // Add a resize observer to detect when the textarea reaches its minimum size
            const resizeObserver = new ResizeObserver(() => {
                checkIfAtMinSize();
            });
            resizeObserver.observe(elements.systemPromptTextarea);
            
            elements.systemPromptSection.querySelector('.settings-section-title').addEventListener('click', () => {
                const wasCollapsed = elements.systemPromptSection.classList.contains('collapsed');
                elements.systemPromptSection.classList.toggle('collapsed');
                app.uiSettings.systemPromptCollapsed = elements.systemPromptSection.classList.contains('collapsed');
                saveUISettings();
                
                // Only restore height when expanding, not when collapsing
                if (wasCollapsed) {
                    setTimeout(() => {
                        restoreSystemPromptHeight();
                    }, 100);
                }
            });
            
            // Settings section event listeners
            elements.parametersSection.querySelector('.settings-section-title').addEventListener('click', () => {
                elements.parametersSection.classList.toggle('collapsed');
                app.uiSettings.parametersCollapsed = elements.parametersSection.classList.contains('collapsed');
                saveUISettings();
            });
            
            elements.interfaceSection.querySelector('.settings-section-title').addEventListener('click', () => {
                elements.interfaceSection.classList.toggle('collapsed');
                app.uiSettings.interfaceCollapsed = elements.interfaceSection.classList.contains('collapsed');
                saveUISettings();
            });
            
            elements.apiSettingsSection.querySelector('.settings-section-title').addEventListener('click', () => {
                elements.apiSettingsSection.classList.toggle('collapsed');
                app.uiSettings.apiSettingsCollapsed = elements.apiSettingsSection.classList.contains('collapsed');
                saveUISettings();
            });
            
            // Avatar event listeners
            elements.avatarInput.addEventListener('change', handleAvatarUpload);
            elements.avatarCropZoomSlider.addEventListener('input', updateAvatarCropZoom);
            elements.avatarCropZoomValue.addEventListener('input', updateAvatarCropZoomFromValue);
            elements.avatarCropCancel.addEventListener('click', closeAvatarCropModal);
            elements.avatarCropSave.addEventListener('click', saveCroppedAvatar);
            elements.avatarCropPreview.addEventListener('mousedown', startAvatarDrag);
            document.addEventListener('mousemove', handleAvatarDrag);
            document.addEventListener('mouseup', endAvatarDrag);
            
            // Group selection event listeners
            elements.groupSelectionCancel.addEventListener('click', closeGroupSelectionModal);
            elements.groupSelectionMove.addEventListener('click', moveChatToSelectedGroup);
            
            // Debug window event listeners
            elements.debugClose.addEventListener('click', () => {
                elements.debugWindow.classList.remove('visible');
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F9') {
                    e.preventDefault();
                    elements.debugWindow.classList.toggle('visible');
                }
            });
            
            // Import/Export event listeners
            elements.exportBtn.addEventListener('click', exportData);
            elements.importBtn.addEventListener('click', importData);
            
            // Debug sampler param event listeners
            elements.debugDryBaseSlider.addEventListener('input', updateDebugSamplerParam);
            elements.debugDryBaseValue.addEventListener('input', updateDebugSamplerParamFromValue);
            elements.debugDryAllowedLengthSlider.addEventListener('input', updateDebugSamplerParam);
            elements.debugDryAllowedLengthValue.addEventListener('input', updateDebugSamplerParamFromValue);
            elements.debugDryPenaltyLastNSlider.addEventListener('input', updateDebugSamplerParam);
            elements.debugDryPenaltyLastNValue.addEventListener('input', updateDebugSamplerParamFromValue);
            elements.debugXtcThresholdSlider.addEventListener('input', updateDebugSamplerParam);
            elements.debugXtcThresholdValue.addEventListener('input', updateDebugSamplerParamFromValue);
            
            // Other event listeners
            elements.dialogueMessages.addEventListener('scroll', handleScroll);
            window.addEventListener('beforeunload', saveLastSelectedChat);
            window.addEventListener('resize', () => {
                syncSendButtonHeight();
                updateResizeHandlePositions();
            });
            document.addEventListener('click', handleGlobalClick);
        }

        // Initialize the application
        function init() {
            loadGlobalSettings();
            loadChatsFromStorage();
            loadGroupsFromStorage();
            loadLastSelectedChat();
            loadDebugSamplerParams();
            setupEventListeners();
            updateSettingsUI();
            applyPanelSettings();
            
            renderChatsList();
            
            if (app.chats.length === 0) {
                createNewChat();
            } else {
                const chatToSelect = app.currentChatId || app.chats[0].id;
                selectChat(chatToSelect);
            }
            
            setTimeout(() => {
                updateSendButton();
                syncSendButtonHeight();
            }, 100);
        }

        // Start the application
        init();
    </script>
</body>
</html>